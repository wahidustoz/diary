{
  "csharp/index.html": {
    "href": "csharp/index.html",
    "title": "C# related posts | Wahid Ustoz",
    "keywords": "C# related posts Here you find all the things related to C# neatly organized."
  },
  "csharp/task-yoki-valuetask.html": {
    "href": "csharp/task-yoki-valuetask.html",
    "title": "Task yoki ValueTask? | Wahid Ustoz",
    "keywords": "Task yoki ValueTask? Task va uning jenerik sherigi Task<TResult> klasi ancha vaqtlardan beri bor va har bir .NETchi asinxron dasturlash uchun uni ishlatib koâ€™rgan. .NET Core 2.0dan boshlab yangi klas ValueTask va ValueTask<TResult> olib kirildi. Hoâ€™sh siz ulardan qaysi birini ishlatishingiz kerak? Qisqa qilib aytganda, agarda siz kutubxona yozayotgan boâ€™lsangiz va shu kutubxona xotirani va resurslarni judayam kam sarflashi zarur boâ€™lgan joylarda ishlatilsa, siz ValueTask haqida bosh qotirsangiz arziydi. Lekin ValueTask ishlatishda judayam extiyotkor boâ€™lish kerak. Odatiy kunlik ishlarda esa Senior darajada boâ€™lmagan dasturchilar Task klasi ishlatgani maâ€™qul. Ushbu postni oxirigacha oâ€™qib tushinib olganingizdan keyin darajangizdan qatiy nazar ValueTask va Taskni qayerda va qanday ishlatishni tushinib olasiz. Task/Task<TResult> Task klasining vaziflari koâ€™p. Qisqa qilib aytganda u uzoq vaqt davom etadigan ish qaytaradigan maâ€™lumotni oâ€™rash uchun wrapper sifatida ishlatiladi va promise yaâ€™ni vaâ€™da deyiladi. Qaytarilgan Task obyektini hohlagan vaqtda await qilib kutib turgan holda natijasini olsa boâ€™ladi. Bundan tashqari shu obyektni hohlagancha qayta-qayta yoki parallel bir nechta threadda await qilsa ham bir xil natija qaytaradi. Bu judaham kuchli yechim! async Task<int> GetNaturalGasPriceInUsdAsync() { await Task.Delay(1000); return 9; } var uzbekNaturalGasPrice = GetNaturalGasPriceInUsdAsync(); var price = await uzbekNaturalGasPrice; var price2 = await uzbekNaturalGasPrice; Yuqoridagi kodda koâ€™rinib turibdiki bitta Task obyektini bir necha marta await qilish mumkin va u bir xil natija qaytaradi. Muammo Unda muammo nimada? Gap shundaki, Task va Task<TResult> klas tiplar boâ€™lib har safar asinxron funksiya chaqirilganda Task yoki Task<TResult> allocate (xotirani oâ€™zlashtirish) qilib qaytarishga toâ€™gâ€™ri keladi. Hullas, har safar funksiya chaqirilganda yangi instance yaratib qaytarish dastur tezligi va xotira samaradorligiga sezilarli taâ€™sir qiladi. Runtimedagi yechimlar Koâ€™p hollarda asinxron funksiyalar sodda boâ€™ladi va ularni bir marta await orqali chaqirish kifoya boâ€™ladi. ... await SendEmailAsync(email, cancellationToken); ... Bundan tashqari, koâ€™p hollarda asinxron funksiya ham ishini sinxron tugatadi yaâ€™ni quyidagi misoldagidek maâ€™lum shartlar bajarilsagina asinxron ish bajariladi yoâ€™qsa funksiya ishini sinxron tugatib Task qaytaradi. public async Task SendEmailAsync(Email email, CancellationToken cancellationToken = default) { if(email is not null) await client.SendEmailAsync(email, cancellationToken); logger.LogInformation(\"Email not sent!\"); } Ushbu koddan tushinish mumkinki baâ€™zi hollarda funksiya hech qanday asinxron ish bajarilmaydi. Bunday holatlar juda ham koâ€™p takrorlangani uchun .NET Runtime oâ€™zi Taskning hech qanday asinxron ish bajarilmaganda qaytariladigan nusxasini Cache qilib oladi va qayta-qayta ishlataveradi. Bu oâ€™sha biz bilgan Task.CompletedTask obyekti. Yuqoridagi kodda agar email null boâ€™lsa Runtime oâ€™zi Task.CompletedTaskni cachedan olib qaytaradi. Agar asinxron ish bajarilsa, yangi Task obyekti allocate qilib qaytariladi. Yana bir misolga qarang. Bir Task<bool> qaytaradigan funksiya bor. Bu funksiyada 3 xil holat bor: darxol sinxron true qaytaradi darxol sinxron false qaytaradi asinxron ravishda uzoq vaqtda true yoki false qaytaradi. Dastlabki ikki holatda Task<bool>dan yangi obyekt allocate qilib qaytarish shart emas. 2 ta dona qiymat boâ€™lgani uchun Runtime ularni allaqachon Cache saqlab qoâ€™ygan boâ€™ladi va oâ€™shalarni qaytaradi. Yaâ€™ni yangi xotira allocate qilinmaydi. Agar funksiya asinxron ish bajarsa, majburan Task<bool> obyekti allocate qilinadi. Quyidagi snippet shuni koâ€™rsatadi. public async Task<bool> ShouldSendEmailAsync(User user, CancellationToken cancellationToken = default) { if(user is null) return false; if(user.IsNew()) return true; return await IsNotAdminAsync() } Lekin hamma narsani ham Cache qilish practical yechim emas. Masalan, Task<int> qaytaradigan funksiyani hamma boâ€™lishi mumkin boâ€™lgan natijalarni Cacheda saqlash Gigabaytlab xotira talab qiladi. Koâ€™plab kutibxonalar shunday Cache texnikasidan foydalanib yangi obyektlar yaratilishini oldini olishadi. Masalan, MemoryStream.ReadAsync funksiyadi Task<int> obyekti orqali nechta bayt oâ€™qilganini qaytaradi. Bu funksiya koâ€™pincha bir xil son qaytargani uchuni ichkarida birinchi qaytarilgan Task<int> obyekti Cache qilinadi. Keyingi safar chaqirilganda, agar yana oâ€™shancha bayt oâ€™qigan boâ€™lsa eski Cache qilingan obyekt qaytariladi. Yoâ€™qsa Task.FromResult ishlatib yangi obyekt yaratiladi. Bu funksiya .NET yangi versiyalarida ValueTask<int> qaytaradigan qilib update qilingan. ValueTask<TResult> Yuqoridagi yechimni yanada takomillashtirish uchun .NET Core 2.0dan boshlab ValueTask<TResult> struct tanishtirildi. U asinxon funksiyalardan qaytariladi va TResult yoki Task<TResult> uchun wrapper vazifasini bajaradi. Agar asinxron funksiya muvaffaqiyatli sinxron yakunlansa, ValueTask<TResult> structi TResult ga initialize qilib qaytarialdi. Hech qanday allocation boâ€™lmaydi. Agar asinxron yakunlansa yoki qandaydir exception sodir boâ€™lsa, yangi Task<TResult> obyekti allocate qilib ValueTask<TResult>ga oâ€™rab qaytariladi. Buning yordamida yuqorida keltirilgan MemoryStream.ReadBytes funksiyasi quyidagicha takomillashtirildi. Endi hech qanday Cache ishlatilmaydi. public override ValueTask<int> ReadAsync(byte[] buffer, int offset, int count) { try { int bytesRead = Read(buffer, offset, count); return new ValueTask<int>(bytesRead); } catch (Exception e) { return new ValueTask<int>(Task.FromException<int>(e)); } } Muhim narsa qolib ketyapti await dasturlash yoâ€™lining eng muhim xususiyatlaridan biri bu asinxron operatsiya yakunlanganda chaqirish imkonini beruvchi callback method bilan taâ€™minlash. Yaâ€™ni Task/Task<TResult> qaytaradigan asinxron funksiyalarga ish tugatilganda chaqiriladigan callback method bersangiz boâ€™ladi. async Task<ZipArchive> CreateZipArchiveFromCloudFiles() { var files await DownloadAllFilesToTempFolderAsync(); return await CreateZipAsync(files); } var zipArchive = await CreateZipArchiveFromCloudFiles() .ContinueWith(async (task) => { await CleanupTempFolderAsync(); }); Buni amalga oshirish uchun xotirada shu operatsiyani aks ettiruvchi obyekt saqlanishi kerak va u orqali callback method chaqirilishi kerak. Shu hususiyatni taâ€™minlash uchun .NET Core 2.1dan boshlab IValueTaskSource<TResult> interface tanishtirildi. Bu interface asinxron operatsiya holati haqida maâ€™lumot saqlaydi va OnCompleted methodi orqali unga yuqoridagidan callback method bersa boâ€™aldi. *IValueTaskSource<TResult> haqida keyingi postlarda.* Endi ValueTask<TResult> va ValueTask structlari birgalikda asinxron funsiyalarni har qanday holatda ham hech qanday hotira allocate qilmasdan natija qaytarish imkonini beradi. ValueTask ishlatishdagi havf ValueTask va ValueTask<TResult> qisqa qilib aytganda oddiy holatlarda bir marta await qilib ishlatiladigan Tasklar uchun chiqarilgan. Quyidagi holatlarda hech qachon ValueTask / ValueTask<TResult> ishlatmaslik kerak. ValueTask / ValueTask<TResult> ni bir martadan ortiq await qilish. ValueTask<TResult> ichidagi TResult obyekti GC tomonidan recycle qilib yuborilgan boâ€™lishi yoki boshqa operatsiya tomonidan ishlatilayotgan boâ€™lishi mumkin **ValueTask / ValueTask<TResult>**ni bir vaqta bir nechta threaddanawait qilish. Yuqoridagiday TResult obyekti bitta thread ishini tugatgach recycle qilib yuborilgan boâ€™lishi mumkin. Operatsiya yakunlanmasidan avval .GetAwaiter().GetResult() funksiyasi orqali blok qilib natijani kutish. IValueTaskSource va IValueTaskSource<TResult> interfacelari blok qilish imkoniyatini bermaydi. Agar sizga yuqoridagi imkoniyatlar chindan ham zarur boâ€™lsa, .AsTask() methodi orqali ValueTask/ValueTask<TResult> larni Taskga aylantirib olsangiz boâ€™ladi. Ushbu maqolada qandaydir xatolik topsangiz habar bering."
  },
  "dotnet/index.html": {
    "href": "dotnet/index.html",
    "title": ".NET and ASP.NET related posts | Wahid Ustoz",
    "keywords": ".NET and ASP.NET related posts Here you find all the latest news, features and updates for .NET. Logging Logging Levels (and how to use them) Logging Code Generators"
  },
  "dotnet/log-code-gen.html": {
    "href": "dotnet/log-code-gen.html",
    "title": "Improve logging performance with code generation | Wahid Ustoz",
    "keywords": "Improve logging performance with code generation Avvalgi postda logging levels __(logging darajalari)__ni tushintirib bergan edim. Bugun logging tezligini oshirish uchun taklif etilayotgan yangi feature Logging Code Generation haqida gaplashamiz. Code generation bu yangilik emas. Avvaldan Blazor, Razor va shunga o'xshash engine'lar compile vaqtida kod generate qiladi. .NET 6 versiyasida olib kirilgan yangi attribute LoggingMessageAttribute bo'lsa aynan Logging samaradorligini oshirish uchun compile vaqtida reusable logging funksiyalari yaratish uchun ishlatiladi. Ushbu qo'shimcha haqida batafsil bu yerda o'qishingiz mumkin. Logging Code generation ishlatish uchun static partial klas yaratib uni ichida partial kalit so'zi orqali methodlar elon qilishingiz kerak. Bu methodlarni tanasi compile vaqtida .NET tomonidan yaratiladi va qayta ishlatiladi. public static partial class ValidationFilterLoggings { [LoggerMessage( EventId = 0, Level = LogLevel.Trace, Message = \"Fluent validation started for type {targetType}.\")] public static partial void LogValidationStarted( this ILogger logger, string targetType); } E'lon qilingan funksiyani tanasi compile vaqtida .NET tomonidan yaratiladi. Keyin ushbu logging methodni quyidagicha ishlatsa bo'ladi. public class AsyncFluentValidationFilter<T> : IEndpointFilter where T : class { private readonly ILogger<AsyncFluentValidationFilter<T>> logger; public AsyncFluentValidationFilter(ILogger<AsyncFluentValidationFilter<T>> logger) => this.logger = logger; public async ValueTask<object> InvokeAsync(EndpointFilterInvocationContext context, EndpointFilterDelegate next) { ... logger.LogValidationStarted(nameof(T)); ... } } Note Yuqorida elon qilingan LogValidationStarted funksiyasi ILogger interface ustiga qurilgani uchun, bu methodni istalgan ILogger interface obyektida ishlatsa bo'ladi. Agar sizga maxsus bitta generic ILogger<T> ustida ishlaydigan mehod kerak bo'lsa, this ILogger<T> shaklida elon qilishingiz kerak. Misol uchun quyidagi kodga qarang ğŸ‘€ public static partial class ValidationFilterLoggings { [LoggerMessage( EventId = 1, Level = LogLevel.Trace, Message = \"Fluent validation for {targetType} is successful.\")] public static partial void LogValidationCompleted( this ILogger<AsyncFluentValidationFilter<T>> logger, string targetType); }"
  },
  "dotnet/log-levels.html": {
    "href": "dotnet/log-levels.html",
    "title": "Logging Levels | Wahid Ustoz",
    "keywords": "Logging Levels Logging dasturni eng muhim qismlaridan biri hisoblanadi. Koâ€™pchilik unga katta eâ€™tibor bermasa ham Logging toâ€™gâ€™ri qilinmasa juda katta mablagâ€™ va vaqt yoâ€™qotilishiga olib kelishi mumkin. Odam yozgan lyuboy sistemada Bug ğŸª² boâ€™ladi. Dastur ishga tushgandan keyin kelib chiqqan xatoliklarni dasturda yozib borilayotgan Loglarsiz qidirib topishni imkoni yoâ€™q. Bugungi postda Log Levels yaâ€™ni log xabarlarni muhimlik darajalariga qarab qanday ishlatishni oâ€™rganamiz. 1. Trace â€” logger.LogTrace() Bu turdagi loglar dastur davomidagi har bir qadamni batafsil yozib ketish uchun ishlatiladi. Yangi jarayon, funksiya, loop yoki oqim boshlanishi va tugaganidan keyin iz qoldirish uchun Trace log yozib ketiladi. public async Task ProcessOrder(CustomerOrder order) { logger.LogTrace(\"Starting order processing for OrderId: {OrderId}\", order.OrderId); // Validate the order if (IsOrderValid(order)) { logger.LogTrace(\"Order validation successful for OrderId: {OrderId}\", order.OrderId); // Perform necessary actions such as updating inventory, sending notifications, etc. logger.LogTrace(\"Persisting order with OrderId: {OrderId}\", order.OrderId); await storage.PersistOrderAsync(order); logger.LogTrace(\"Publishing OrderCreated message with OrderId: {OrderId}\", order.OrderId); await messaging.PublishOrderCreated(order); } } 2. Debug â€” logger.LogDebug() Bu turdagi log Tracega juda ham yaqin, lekin yagona farqi Debug log ichida oâ€™zgaruvchilar qiymatlari batafsilroq yoritiladi. Shu sababli bu turdagi log ichida maxfiy maâ€™lumotlar boâ€™lishi mumkin. Debug va Trace log miqdori juda katta boâ€™lgani uchun odatda Production muhitda oâ€™chirib qoâ€™yish tavsiya qilinadi. Shaxsiy fikrimcha Debug yoki Trace darajasidan kamida bittasi Production muhitda ham koâ€™rinishi kerak. public async Task ProcessOrder(CustomerOrder order) { logger.LogTrace(\"Starting order processing for OrderId: {OrderId}\", order.OrderId); logger.LogDebug(\"Processing order: {Order}\", order); // Validate the order if (IsOrderValid(order)) { logger.LogTrace(\"Order validation successful for OrderId: {OrderId}\", order.OrderId); logger.LogDebug(\"Order validation successful for: {Order}\", order); // Perform necessary actions such as updating inventory, sending notifications, etc. logger.LogTrace(\"Persisting order with OrderId: {OrderId}\", order.OrderId); logger.LogDebug(\"Persisting order: {order}\", order); await storage.PersistOrderAsync(order); logger.LogTrace(\"Publishing OrderCreated message with OrderId: {OrderId}\", order.OrderId); logger.LogDebug(\"Publishing OrderCreated for order: {order}\", order); await messaging.PublishOrderCreated(order); } } Summary Yuqorida keltirilgan LogTrace va LogDebug odatda dasturchilar uchun yoâ€™naltirilgan boâ€™ladi. Yaâ€™ni bu turdagi loglarni odatda developerlar BUGğŸª²ni qidirib topish uchun ishlatishadi. 3. Information â€” logger.LogInformation() Bu turdagi log odatda biror katta jarayon boshlanishi va muvaffaqiyatli tugaganini koâ€™rsatish uchun ketiladi. Trace va Debugdan farqli oâ€™laroq, Information turidagi xabarlar miqdori juda kam boâ€™ladi. Bunday log ichida iloji boricha maxfiy maâ€™lumotlar koâ€™rsatilmasligi kerak. public async Task ProcessOrder(CustomerOrder order) { logger.LogTrace(\"Starting order processing for OrderId: {OrderId}\", order.OrderId); logger.LogDebug(\"Processing order: {Order}\", order); // Validate the order if (IsOrderValid(order)) { logger.LogTrace(\"Order validation successful for OrderId: {OrderId}\", order.OrderId); logger.LogDebug(\"Order validation successful for: {Order}\", order); // Perform necessary actions such as updating inventory, sending notifications, etc. logger.LogTrace(\"Persisting order with OrderId: {OrderId}\", order.OrderId); logger.LogDebug(\"Persisting order: {order}\", order); await storage.PersistOrderAsync(order); logger.LogTrace(\"Publishing OrderCreated message with OrderId: {OrderId}\", order.OrderId); logger.LogDebug(\"Publishing OrderCreated for order: {order}\", order); await messaging.PublishOrderCreated(order); logger.LogInformation(\"Order with orderId {OrderId} successfully processed.\", order.Id); } } 4. Warning â€” logger.LogWarning() Warning xabarlar dasturda kutilmagan holat yoki notoâ€™gâ€™ri maâ€™lumot paydo boâ€™lganda qoldiriladi. Bunday holat yuz berganda dasturchi, sistema admini yoki dasturni oâ€™zi ham hech qanday amal bajarish orqali xatoni tuzatishga urinishi shart emas. Bu xabarni muhim tarafi, sistemadagi bu kutilmagan holat keyinchalik eâ€™tibor talab etuvchi jiddiy xatolikka olib borishi mumkin. public async Task ProcessOrder(CustomerOrder order) { logger.LogTrace(\"Starting order processing for OrderId: {OrderId}\", order.OrderId); logger.LogDebug(\"Processing order: {Order}\", order); // Validate the order if (IsOrderValid(order)) { logger.LogTrace(\"Order validation successful for OrderId: {OrderId}\", order.OrderId); logger.LogDebug(\"Order validation successful for: {Order}\", order); // Perform necessary actions such as updating inventory, sending notifications, etc. logger.LogTrace(\"Persisting order with OrderId: {OrderId}\", order.OrderId); logger.LogDebug(\"Persisting order: {order}\", order); await storage.PersistOrderAsync(order); logger.LogTrace(\"Publishing OrderCreated message with OrderId: {OrderId}\", order.OrderId); logger.LogDebug(\"Publishing OrderCreated for order: {order}\", order); await messaging.PublishOrderCreated(order); logger.LogInformation(\"Order with orderId {OrderId} successfully processed.\", order.Id); } else { logger.LogDebug(\"Validation failed for order {order}\", order); // batafsil ma'lumot qoldirish uchun logger.LogWarning(\"Validation failed for order with id: {OrderId}\", order.Id); logger.LogDebug(\"Publishing OrderFailed for order: {order}\", order); await messaging.PublishOrderFailed(order); } } 5. Error â€” logger.LogError() Error xabarlar biror katta yumush bajarish jarayonida xatolik yuz berib shu funksiya oxiriga yeta olmasa qoldiriladi. Error xabar qoldirilish shu jarayon oxiriga yetmay qolganini lekin sistemaning boshqa qismlariga taâ€™sir qilmasligini anglatadi. Odatda Error xabarlarni sistemani oâ€™zinig Error Handling, Retry mexanizmlari bartafar qiladi. Ayrim hollarda operatorlar maâ€™lumot xolatini oâ€™zgartirish orqali ham bu Error holatdan chiqib ketishlari mumkin. Error xabar yuz berganda Operatorlar yoki dasturchilar uyqularidan turib boâ€™lsa ham shu xatolikni bartaraf etishlari kerak. Shuning uchun bu turdagi xatoliklarni log qilishda shoshilmaslik kerak. Operator va dasturchini uyqusini buzishga arziydimi degan savolni berish kerak. public async Task ProcessOrder(CustomerOrder order) { logger.LogTrace(\"Starting order processing for OrderId: {OrderId}\", order.OrderId); logger.LogDebug(\"Processing order: {Order}\", order); // Validate the order if (IsOrderValid(order)) { logger.LogTrace(\"Order validation successful for OrderId: {OrderId}\", order.OrderId); logger.LogDebug(\"Order validation successful for: {Order}\", order); try { // Perform necessary actions such as updating inventory, sending notifications, etc. logger.LogTrace(\"Persisting order with OrderId: {OrderId}\", order.OrderId); logger.LogDebug(\"Persisting order: {order}\", order); await storage.PersistOrderAsync(order); logger.LogTrace(\"Publishing OrderCreated message with OrderId: {OrderId}\", order.OrderId); logger.LogDebug(\"Publishing OrderCreated for order: {order}\", order); await messaging.PublishOrderCreated(order); } catch(DbException ex) { logger.LogError(\"Order processing failed for order with id: {OrderId}\", order.Id); throw new OrderProcessingFailedException(order, ex); } logger.LogInformation(\"Order with orderId {OrderId} successfully processed.\", order.Id); } else { logger.LogDebug(\"Validation failed for order {order}\", order); // batafsil ma'lumot qoldirish uchun logger.LogWarning(\"Validation failed for order with id: {OrderId}\", order.Id); logger.LogDebug(\"Publishing OrderFailed for order: {order}\", order); await messaging.PublishOrderFailed(order); } } 6. Critical â€” logger.LogCritical() Bunday Log sistemani barcha qismlarini ishdan chiqaruvchi xatolikni yozish uchun ishlatiladi. Masalan, RAM yoki SSD xotira tugab qolishi, butun dastur boâ€™ylab Databaseâ€™ga bogâ€™lana olmaslik yoki shunga oâ€™xshash dastur ishlashi uchun soâ€™zsiz kerak resursni yoâ€™qligi. Bunday xatoliklar dastur davomida bir marta yuz beradi. Yaâ€™ni Critical error yuz bergandan keyin dastur oâ€™chib qolishi va Sistem adminstrator tomonidan qayta yoqilishi zarur. Critical error xabar yuz berganda Sistem Adminstrator uyqusidan turib boâ€™lsa ham xatolikni bartaraf etishi kerak. builder.Services.AddDbContext<AppDbContext>((provider, options) => { var logger = provider.Services.GetRequiredService<ILogger<Program>>(); var connectionString = builder.Configuration.GetConnectionString(\"Postgres\"); if(string.IsNullOrWhiteSpwace(connectionString)) { logger.LogCritical(\"Postgres connection string not configured.\"); Environment.Exit(-1); } options.UseNqgsql(connectionString); }); Yuqoridagi misollardan koâ€™rinib turibdi agar dastur davomida yetarlicha log xabarlar qoldirmoqchi boâ€™lsangiz kodda judaham noise (shovqin â€” chalgâ€™ituvchi qismlar) juda koâ€™payib ketadi. Buni oldini olish uchun Logging Abstraction qoâ€™llash kerak. Bu haqida batafsil keyingi postda."
  },
  "index.html": {
    "href": "index.html",
    "title": "Welcome to Wahid Ustoz Programming Blog! ğŸ’» ğŸš€ | Wahid Ustoz",
    "keywords": "Welcome to Wahid Ustoz Programming Blog! ğŸ’» ğŸš€ Are you passionate about programming and interested in staying up-to-date with the latest tips, news, and tutorials on .NET, C#, VSCode, Devops, and C++ technologies? Look no further! Our programming blog is here to provide you with valuable insights and resources to enhance your coding skills and knowledge. ğŸ“ ğŸ’¡ What can you expect from our blog? ğŸ” Programming Tips: Discover useful tips and tricks that can help you write more efficient and elegant code in .NET, C#, VSCode, Devops, and C++. âœ¨ News and Updates: Stay in the loop with the latest updates and trends in the world of programming. We cover industry news, new releases, and technology advancements. ğŸ“° ğŸ“¢ Tutorials: Step-by-step tutorials to guide you through various programming concepts and techniques. Learn how to build applications, solve common challenges, and leverage powerful tools and frameworks. ğŸ“š ğŸ’» Our focus areas ğŸ¯ Our blog specializes in the following programming technologies: .NET: Explore the world of .NET development, including frameworks like ASP.NET, .NET Core, and Xamarin. Learn how to build scalable and robust applications using the power of .NET ecosystem. âš™ï¸ ğŸ—ï¸ C#: Dive into the C# programming language and discover its features, best practices, and advanced topics. From beginner-friendly tutorials to advanced concepts, we've got you covered. ğŸŒˆ ğŸ’ª VSCode: Unleash the full potential of Visual Studio Code, one of the most popular text editors for developers. Discover handy tips, extensions, and workflows to boost your productivity. âš¡ ğŸ’» Devops: Learn how to streamline your software development and deployment processes with DevOps practices. Explore tools like Docker, Kubernetes, CI/CD pipelines, and more. ğŸ³ ğŸš€ âš™ï¸ C++: Delve into the world of C++ programming and explore its powerful features for system-level and performance-critical applications. From basics to advanced topics, we'll help you master C++. ğŸ› ï¸ âš™ï¸ Join our community! ğŸ¤ ğŸŒ We're excited to have you on board! Join our community of passionate programmers and never miss an update. Subscribe to our newsletter, follow us on social media, and engage in discussions with fellow developers. ğŸ’¬ ğŸ™Œ Happy coding! ğŸ‰ âŒ¨ï¸"
  }
}