{
  "algorithms/binaryheap.html": {
    "href": "algorithms/binaryheap.html",
    "title": "Binary Heap C# | Data Structure | wahidustoz",
    "summary": "Binary Heap C# | Data Structure Binary Heap data structure ma'lumotlarni to'plamga juda tez qo'shish O(log N) va shu to'plamdagi eng katta/kichik elementni konstant O(1) vaqtda o'qish imkonini beradigan complete tree]. U heap sort, priority queue va Dijkstra's algoritmlarini o'zagi hisoblanadi. Intro \uD83D\uDC4B Uni 2 ta asosiy hususiyatlari bor: ✔️ Complete Tree ✔️ Heap Property Ushbu post orqali siz Binary Heapni C# dasturlash tilida eng sodda usulda tushintirilishi visual elementlar orqali o'rganasiz \uD83D\uDE80 Note Ish maydonini tayyorlab olish uchun Heap.cs nomli fayl yarating va uni ichida empty Heap deb nomlangan class yozing. public class Heap<T> where T : IComparable<T> Heap strukturaasi ichida istalgan turdagi ma'lumot saqlay olishni ta'minlash uchun uni generic Heap<T> qilib e'lon qilamiz. Heapdagi where T : IComparable<T> constrainti heap propertyni saqlash uchun solishtirishda ishlatiladi. Node class \uD83E\uDD6C Data Stucture olamida node iborasi juda ko'p ishlatiladi. Ular strukturani o'zagi bo'lib ma'lumotlarni o'rab turishda ishlatialdi. Binary Heap strukturasida har bir node quyidagi elementlarni o'z o'chiga oladi. Value - asosiy saqlanayotgan ma'lumot Left- chap tarafdagi child-nodega reference Right - o'ng tarafdagi child-nodega reference \uD83D\uDCA1 Node klasi faqat Heap kaslini ichki amallarida ishlatigani uchun uni private qilib Heap class ichida elon qilamiz. public class Heap<T> where T : IComparable<T> { private class Node(T value) { public T Value { get; set; } = value; private Node right = default; public ref Node Right => ref right; private Node left = default; public ref Node Left => ref left; DETAIL \uD83D\uDCA1 Node classida C# 12dagi primary constructor hususiyati ishlatilgan. private class Node(T value) Right va Left child-nodelarni keyinchalik to'liq manipulatsiya qila olishimiz va C# da propertylarga ref kalit so'zini qo'yish mumkin emasligi uchun ref orqali private backing fieldlar e'lon qilib ma'lumotlarni shu fieldlarda saqlaymiz. Keyin u fieldlarga propertylar orqali murojat qilamiz. private Node right = default; public ref Node Right => ref right; private Node left = default; public ref Node Left => ref left; \uD83D\uDCA1 Keling endi Node classiga keynchalik asqotadigan helper methodlar qo'shib chiqamiz. Node.Size \uD83D\uDCCF DETAIL public int Size => (left?.Size ?? 0) + (right?.Size ?? 0) + 1; Node classidagi Size propertysi recursive tarzda joriy Node hajmini aniqlaydi. Har bir nodening sizei 1 + Left.Size + Right.Sizega teng. Node.SmallerChild DETAIL Ushbu property joriy Nodeni kichikroq childiga reference qaytaradi. public ref Node SmallerChild { get { if(Left is null) return ref Left; else if(Right is null) return ref Right; else if(left.Size <= right.Size) return ref Left; else return ref Right; } } ⭐ Endi Node classini asosiy methodlariga o'tamiz. Node.Heapify() DETAIL Heapify funksiyasi heap propertyni saqlab qolishni ta'minlaydi. public void Heapify() { if(Left is not null && Left.Value.CompareTo(Value) < 0) SwapValueWith(Left); if(Right is not null && Right.Value.CompareTo(Value) < 0) SwapValueWith(Right); } Min-heap: har bir node uchun parent-node qiymati child-nodelar qiymatidan KICHIK yoki teng bo'lishi shart. Max-heap: har bir node uchun parent-node qiymati child-nodelar qiymatidan KATTA yoki teng bo'lishi shart. Warning Rasmda Max-heap ifodalangani uchun 3 va 1 qiymatlari swap qilinishi kerak. Node.SwapValueWith(Node other) DETAIL Ushbu funksiya joriy node qiymatini berilgan node qiymati bilan alishtiradi. public void SwapValueWith(Node other) => (other.Value, Value) = (Value, other.Value); E'tibor bering, faqat qiymatlar alishtirilgani uchun bu funksiyada hech qanday ref kalit so'zi ishlatilmagan. ⭐ Ana endi navbat Heap classini o'ziga keldi. Uni memberlari haqida birma-bir to'xtalamiz. Heap.root Heap classida root nomli private field yasab olamiz. U data strukturamiz boshlanish nuqtasi vazifasini bajaradi va birinchi nodega reference bo'ladi. Har safar Heapni traverse qilish shu objectdan boshlanadi. private Node head = default; Heap classida tashqariga ko'rinuvchi 3ta asosiy public methodlari mavjud. Ularni har biri haqida quyida batafsil to'xtalamiz. Print() - Heap classini traverse qilib har bir node qiymatini chop etish uchun. Enqueue(T value) - yangi qiymatni kerakli joyga joylash uchun. T Dequeue() - eng tepadagi birichi elementni qaytarib uni o'chirib yuboradi va heap propertyni qayta hisoblab qo'yadi. Heap.Enqueue public void Enqueue(T value) => EnqueueRecursive(ref head, new Node(value)); private void EnqueueRecursive(ref Node current, Node newNode) { if(current is null) current = newNode; else if(current.Left is null) current.Left = newNode; else if(current.Right is null) current.Right = newNode; else EnqueueRecursive(ref current.SmallerChild, newNode); current.Heapify(); } DETAIL Ko'rib turganingizdek Enqueue() public methodi shunchaki EnqueueRecursivega kerakli parametrlarni uzatib yuboradi holos. Asosiy logika ushbu private recursive method ichida amalga oshadi. Yangi elementi qo'shish O(log n) vaqt talab qiladi. Logikaga e'tibor bering, shunchaki recursive tarzda null reference ya'ni Heap tubiga yetib tushmaguncha kichikroq shox tanlab, shu shox bo'ylab tushib boriladi. null referencega yetib kelganda, yangi node shu yerga joylanadi. ref imkoniyati bilan, current obyekti qiymati null bolsa, ushbu obyekt referenci yangi yaratilgan nodega qaratib qo'yiladi. Let that sink in! \uD83E\uDD2F. Method oxirida current.Heapify(); chaqiruvi heapni eng tubiga tushib ortga rekursiv qaytish vaqtida har bir nodening heap propertysini qayta hisoblab qo'yadi \uD83D\uDCA5. Heap.Dequeue public T Dequeue() { if(head is null) throw new InvalidOperationException(\"Heap is empty.\"); var temp = head.Value; HeapifyDownRecursive(ref head); return temp; } private void HeapifyDownRecursive(ref Node current) { if(current.Left is null && current.Right is null) current = null; else if(current.Right is null) { current.SwapValueWith(current.Left); HeapifyDownRecursive(ref current.Left); } else if(current.Left is null) { current.SwapValueWith(current.Right); HeapifyDownRecursive(ref current.Right); } else if(current.Left.Value.CompareTo(current.Right.Value) < 0) { current.SwapValueWith(current.Left); HeapifyDownRecursive(ref current.Left); } else { current.SwapValueWith(current.Right); HeapifyDownRecursive(ref current.Right); } } DETAIL Dequeue() - bu root-node o'chiriladi va uni o'rniga ikkita childdan biri priority bo'yicha tanlab olinadi, va huddi shu tartibda uni childlari ham bittadan yuqoriga siljiydi Dequeue ham Enqueue kabi O(log n)** vaqt talab qiladi. Avvalo heap empty bo'lsa InvalidOperationException otamiz. Yo'qsa, rekursiv tarzda eng kichik qiymatli elementni current bilan swap qilib, pastga qarab ketaveramiz. leaf-nodega yetib borganimizda, uni null referencega tenglab qo'yamiz. Bu orqali osha eng oxiridagi nodeni o'chirgan bo'lamiz. Xotirani bo'shatishni GC o'zi qoyillatadi. Heap.Print public void Print() { var queue = new Queue<Node>(); if(head is not null) queue.Enqueue(head); while(queue.Any()) { var node = queue.Dequeue(); Console.Write(\"{0} \", node.Value); if(node.Left is not null) queue.Enqueue(node.Left); if(node.Right is not null) queue.Enqueue(node.Right); } Console.WriteLine(); } DETAIL Print funksiyasida qiymatlarni to'g'ri ketma ketlikda chop etish uchun Queue strukturasidan foydalanilgan. Queueda nodelar qolmaguncha birinchi nodeni olib chop etamiz va uni child nodelarini queuega qo'shib ketaveramiz. Shu orqali har bir qatordagi node chapdan o'ngga qarab bir xilda chop etib ketaveramiz. Heap.Print Vanihoyat Heap klasimizdan obyekt olib uni sinab ko'rsak bo'ladi \uD83D\uDE0E // Program.cs: testing var heap = new Heap<int>(); int[] sonlar = [2, 3, 1, 5, 0, 6, 4]; foreach(var son in sonlar) heap.Enqueue(son); heap.Print(); for(int i = 0; i < 10; i++) Console.WriteLine(heap.Dequeue()); Console.WriteLine(heap.Dequeue()); // Exception ⭐ To'liq kodni mana bu yerda topasiz. ⭐ Kontent yoqqan bo'lsa unga izoh qoldirish va do'slaringizga ulashish orqali sifatli o'zbek tilidagi kontentni qo'llab quvvatlashingizni so'raymiz ❤️. HINT Keyingi maqolada Binary Heap Data Structureni eng ko'p uchraydigan use caselarini misollar orqali o'rganamiz. Shu kabi sifatli o'zbek tilidagi kontentni qo'llab quvvatlash uchun bizni Telegram Kanalimizga obuna bo'ling. Wahid Abduhakimov"
  },
  "algorithms/hashmaps.html": {
    "href": "algorithms/hashmaps.html",
    "title": "Hash Maps #️⃣ - intervyu kaliti \uD83D\uDD11 | wahidustoz",
    "summary": "Hash Maps #️⃣ - intervyu kaliti \uD83D\uDD11 HashMap Data Structure tech intervyularda eng ko'p so'raladigan agoritmlardan biri. Lekin ajoyib hushxabar bor \uD83E\uDD29 HashMapni eng ko'p uchraydigan 2ta holatda ishlatishni o'rganib olsangiz yetarli! Ushbu post davomida ikkala holatni ham misollar yordami o'rganib olasiz. 1. Element mavjudligini aniqlash. Array ichida element bor/yo'qligini tekshirish linear \\(O(N)\\) vaqt talab etadi. Ya'ni array ichidagi $N$ta elementlarni tekshirib chiqish kerak. HashMap esa shu operatsiyani constant \\(O(1)\\) vaqt ichida bajaradi. Tasavvur qiling sizda shu tekshirish operatsiyasini \\(M\\) marta takrorlashingiz kerak. Array ustida bu \\(O(NM)\\) vaqt talab qilsa, HashMap ustida \\(O(M)\\) vaqt oladi. Bu nazariyani quyidagi LeetCode misollari orqali isbotlaymiz. Two Sum int array nums va int target berilgan bo'lsa, array ichidan yig'indisi targetga teng 2ta elementlar indexlarini qaytarish kerak. \uD83D\uDC49 Masalaga havola public class Solution { public int[] TwoSum(int[] nums, int target) { var juftlar = new Dictionary<int, int>(); for(int i = 0; i < nums.Length; i++) if(juftlar.ContainsKey(target - nums[i])) return new int[] { i, juftlar[target - nums[i]]}; else juftlar.TryAdd(nums[i], i); return new int[] { }; } } Tip Yuqoridagi yechimda HashMapga asoslangan Dictionary ishlatilgan. Qisqacha, arraydagi har bir elementni juftini Dictionarydan qidiramiz. Agar jufti yo'q bo'lsa, shu elementni Dictionaryga qo'shamiz. Dictionarydan qidirish \\(O(1)\\) vaqt talab qiladi. Bu amal for loop ichida \\(N\\) marta takrorlangani uchun yechim umumiy \\(O(N)\\) vaqt talab qiladi. Counting Elements Berilgan array ichida x + 1 jufti mavjud bo'lgan x qiymatli elementlar sonini qaytarish kerak. Agar shunday sonlar bir nechta bo'lsa, hammasi alohida sanalsin. \uD83D\uDC49 Masalaga havola public class Solution { public int CountElements(int[] nums) { var frequency = new Dictionary<int, int>(); foreach(var num in nums) { frequency.TryGetValue(num, out var value); frequency[num] = value + 1; } var count = 0; foreach(var num in nums) if(frequency.ContainsKey(num + 1)) count++; return count; } } Tip Bu yechimda ham HashMap sifatida **C#**ning Dictionary classi ishlatilgan. Array elementlari necha marta takrorlanishini Dictionaryga saqlab olamiz. Keyingi loopda shu map ichidan \\(x+1\\) qiymatli elementlarni qidiramiz. Ikkala loop ham \\(O(N)\\) vaqt sarflagani uchun umumiy algoritm \\(O(N)\\) vaqt oladi. First Letter to Appear Twice Kichik lotin harflaridan iborat string berilganda ikki marta takrorlanuvchi birinchi harfni qaytaring. \uD83D\uDC49 Masalaga havola Warning Ushbu yechimni mashq sifatida o'zingiz bajarib ko'ring. Savollar va mulohazalaringizni o'zingizga o'xshagan qiziquvchan dasturchilar bilan Telegram Kanalimizda ulashing ✍️. 2. Takrorlanishlar sonini sanash HashMap yordamida istalgan elementni to'plamdagi chastotasini aniqlash juda ham oson. Masalan, string ichidagi belgilar chastotasi bir xil yoki yo'qligini aniqlash. HashMap yordami berilgan tekst ichidagi har bir belgi chastotasi bir xil yo'qlini bitta loop orqali \\(O(N)\\) linear vaqt ichida aniqlasa bo'ladi. Keling yana misollar yordamida isbotlaymiz. Subarray Sum Equals K int array nums va int k berilgan bo'lsa, yig'indisi k ga teng bo'lgan subarraylar sonini qaytaring. Subarray - ketma-ket joylashgan elementlardan tashkil topgan kichi array. \uD83D\uDC49 Masalaga havola public class Solution { public int SubarraySum(int[] nums, int k) { var sumsMap = new Dictionary<long, int>(); var count = 0; long sum = 0; foreach(var num in nums) { sum += num; if(sum == k) count++; if(sumsMap.TryGetValue(sum - k, out var frequency)) count += frequency; sumsMap.TryGetValue(sum, out var x); sumsMap[sum] = x + 1; } return count; } } Tip Yuqoridagi yechimda barcha subarraylar yig'indisini hisoblab ketish bilan bir vaqtda, shu yig'indini HashMapga joylab, agar mavjud bo'lsa chastotasini oshirib ketamiz. Har bir loop iterationda yig'indi \\(K\\) ga teng bo'lsa sanoqni birga oshiramiz Agar HashMap ichida joriy yig'indini jufti \\(sum - k\\) mavjud bo'lsa, o'sha kalitli elementni chastotasini sanoqqa qo'shamiz. HashMapdan qidirish \\(O(1)\\) vaqt olgani va bu operatsiya \\(N\\) marta takrorlangani uchun umumiy algoritm \\(O(N)\\) vaqt oladi. Maximum Number of Balloons text deb nomlangan string berilgan bo'lsa, undagi balloon takrorlanishlar sonini qaytaring. \uD83D\uDC49 Masalaga havola public class Solution { public int MaxNumberOfBalloons(string text) { var map = new Dictionary<char, int> { { 'b', 0 }, { 'a', 0 }, { 'l', 0 }, { 'o', 0 }, { 'n', 0 }, }; foreach(var c in text) if(map.TryGetValue(c, out var frequency)) map[c] = ++frequency; // l va o ikki martadan keladi map['l'] /= 2; map['o'] /= 2; var min = int.MaxValue; foreach(var value in map.Values) min = Math.Min(min, value); return min; } } Tip Yechimda yana HashMap yordamida harflar chastotasi saqlangan. Keyin esa bu mapdan eng kichik chastota tanlab olingan. Chunki shu eng kam marta takrorlangan harf balloon so'zini ko'pi bilan necha marta hosil qila olishimizni belgilaydi. Kod juda ham oddiy, tushinish muammo bo'lmasa kerak. Etiborga loyiq jihati 2ta loop ishlatilgan bo'lsa ham algoritm umumiy murakkabligi $O(N)$ligicha qoladi. balloon so'zida 'o' va 'l' harflari 2 martadan takrorlangani uchun, ularni chastotatsini 2ga bo'lib qoyganmiz \uD83D\uDC4B Hulosa HashMap yoki HashTable Data Structure dasturlashdagi eng muhim va juda ko'p uchraydigan algoritmlar. Ularni o'rganish va mashq qilish orqali nafaqat intervyu savollarida balki injinerlik faoliyatingizda ham sezilarli samara bo'ladi. HINT Keyingi maqolada Binary Heap Data Structureni **C#**ni eng zamonaviy featurelarini qo'llagan holda implementatsiya qilamiz. Shu kabi sifatli o'zbek tilidagi kontentni qo'llab quvvatlash uchun bizni Telegram Kanalimizga obuna bo'ling. Wahid Abduhakimov"
  },
  "algorithms/index.html": {
    "href": "algorithms/index.html",
    "title": "| wahidustoz",
    "summary": "Algorithms / Data Structures :abacus: Here we explore some of the most commonly used algoritms and data structures with easy to follow examples. \uD83D\uDDDD️ Hash Maps - intervyu kaliti Binary Heap C# | Data Structure"
  },
  "csharp/csharp-12.html": {
    "href": "csharp/csharp-12.html",
    "title": "| wahidustoz",
    "summary": "C# 12 \uD83D\uDE32 Ushbu qismda qismda C# 12dagi eng \uD83C\uDD92 featurelarni ko'rib chiqamiz. ⭐ Primary Constructor class va struct tiplarini elon qilishda bira to'la endi asosiy konstruktor berib ketsa bo'ladi. Primary Constructor orqali yuborilgan obyektlar klass hududi bo'ylab ko'rinadi. Tip Primary constructor orqali yuborilgan obyektlar class memberi emas aksincha parametr ekanini yoddan chiqarmaslik kerak. Ularni this kalit so'zi orqali chaqirib bo'lmaydi. struct misolida. public readonly struct Nuqta(int x, int y) { public readonly int X => x; public readonly int Y => y; } ota classga ma'lumot uzatish. public class Ustoz(int id, string ism) : Ishchi(id) { public int Id => id; public string Ism => ism; } Va eng keraklisi dependency injection. public interface IService { Distance GetDistance(); } public class ExampleController(IService service) : ControllerBase { [HttpGet] public ActionResult<Distance> Get() { return service.GetDistance(); } } \uD83D\uDCA1 Collection Expressions Endi to'plamlarni e'lon qilishda new kalit so'zini ishlatishni hojati yo'q \uD83D\uDE32. int[] sonlar = [1, 2, 3, 4, 5]; List<string> ismlar = [\"Ali\", \"Vali\", \"Hasan\"]; double[] qator1 = [1, 2, 3]; double[] qator2 = [4, 5, 6]; // ko'p o'lchamli array yasash double[][] jadval = [qator1, qator2, [7, 8, 9]]; \uD83D\uDCA3 Spead Operator Agar yuqoridagilari hali miyyangizni portlatmagan bo'lsa unda bunisiga qarang. Spread Operator .. yordami mavjud to'plamlarni yangi to'plamga osonlik bilan qo'shing! string[] qizlar = [\"Madina\", \"Hadicha\", \"Aisha\"]; string[] yigitlar = [\"Umar\", \"Ali\", \"Abubakr\"]; string[] hamma = [\"Wahid\", ..yigitlar, ..qizlar]; // hamma = [\"Wahid\", \"Umar\", \"Ali\", \"Abubakr\", \"Madina\", \"Hadicha\", \"Aisha\"] \uD83C\uDF20 Default Lambda parameters lambda expression elon qilishda endi uning parametrlariga default qiymatlarni berib ketsa bo'ladi. var yuza = (int a, int? b = null) => a * (b ?? a); Console.WriteLine(yuza(5)); // 25 Console.WriteLine(yuza(5, 6)); // 30 Bu yangi feature eng ko'p ishlatilishi kutilyapkan yana bir misol. app.MapGet(\"/users\", async (IUserService service, int? page = 1, int? pageSize = 50) => { }); Tip Yuqorida lambda expression yangi imkoniyatidan foydalanib Pagination uchun default qiymatlar berib ketilgan. Wahid Abduhakimov"
  },
  "csharp/index.html": {
    "href": "csharp/index.html",
    "title": "| wahidustoz",
    "summary": "C# related posts Here you will find a comprehensive collection of resources and information meticulously curated for C# enthusiasts. Task vs ValueTask \uD83D\uDE32 C# 12 ✂️ Remove metodi"
  },
  "csharp/remove.html": {
    "href": "csharp/remove.html",
    "title": "C#'da Remove() | wahidustoz",
    "summary": "C#'da Remove() C# tilida Array'ni ochganimizdan so'ng uni o'zgartira olmaymiz, chunki Array'lar C#'da immutable ya'ni o'zgarmas. Lekin qonun-qoidalarni aylanib o'tishimiz mumkin. Ya'ni Array'ni List ga o'zgartirib, kerakli ishlarni bajarib (masalan undan biror-bir element'ni olib tashlash listName.Remove()) so'ng yana Listni Array'ga aylantirib qo'ya olamiz. Lekin List tipida usha listName.Remove() qanday ishlaydi? Hozir birma-bir ko'rib chiqamiz. 1. Array'ni List tipiga o'tkazib olish int[] array = { 1, 2, 3, 4, 5 }; List<int> list = new List<int>(array); // List<T>'ga aylantirish 2. List'dan elementni o'chirib tashlash list.Remove(3); // 3 raqamini o'chiradi array = list.ToArray(); // Qaytadan Array'ga aylantirish // Array'ning qiymati {1, 2, 4, 5} Array'imiz o'zgardi. Lekin bizga yordam bergan Remove()'ni ishlatganimizda (kapot ostida) xotirada nimalar sodir bo'ldi, endi hozir buni ko'rib chiqamiz. 1. Dinamik hajm o'zgarishi Capacity va Count. List<T>ning ikki muhim xususiyati bor -> Count (List'dagi mavjud bo'lgan elementlar soni) va Capacity (List o'zining hajmini o'zgartirmasdan umumiy nechta element saqlay olishi soni (qisqacha hajmi)). List<T> ochganimizda uning Capacitysi 0 ga teng bo'ladi. List'ga element qo'shganimiz sari agarda Countning soni Capacityning soniga teng bo'lib qolsa List<T> resize bo'ladi ya'ni hajmi o'zgaradi va Capacityimiz avtomatik ravishda 4 taga oshadi. 2. Elementi o'chirib tashlash Qachonki biz Remove() chaqirganimizda quyidagi ishlar sodir bo'ladi: Remove() metodini chaqirganimizda, Listimiz birinchi bo'lib biz o'chirmoqchi bo'lgan element'ni qidiradi. Bu bolsa itaration ya'ni uni aylanib chiqishiga olib keladi. Element'ni topib uni o'chirib tashlagandan so'ng, o'chirib tashlangan element'dan keyingi (ya'ni o'ng taraf) elementlar o'chirib tashlanganning o'rnini bosish uchun chapga shift qilinadi ya'ni suriladi. (Agarda o'chirib tashlangan element so'ngi element bo'lsa unda shift qilinmaydi.) Masalan sizda quyidagi list bor: Index: 0 1 2 3 4 Values: [10, 20, 30, 40, 50] Agarda siz 30ni o'chirib tashlasangiz list quyidagi ko'rinishga keladi: Index: 0 1 2 3 Values: [10, 20, 40, 50] 3. Count'ning kamayishi Bitta element o'chib ketganidan so'ng Count'imiz bittaga kamayadi. 4. Xotiradagi ishlar Listning Capacitysi element'ni o'chirib tashlaganimizdan so'ng bittaga kamaymayib qolmaydi. Listning tagida yotgan Arrayning hajmi usha-usha turaveradi va oldin qancha joy egallab turgan bo'lsa ushancha egallab turaveradi. Ammo biz Remove() qilishda to'xtamay davom etaversak bu Countning Capacitydan o'ta sezilarli ravishda kichik bo'lishiga olib keladi. Bundan so'ng qachonki siz List<T>ga element qo'shganingizda, Capacity ko'payish o'rniga kamayishi mumkin. Bu ish esa List<T>ning tagida yotgan Array'ning o'rniga yangi Array ochiladi va barcha element'lar u yerga ko'chirib o'tkaziladi. Xulosa Xulosa qilib aytadigan bo'lsak, Remove() ishlatganimizda -> element qidiriladi, o'chirib tashlangandan so'ng qolgan elementlar chapga suriladi, Count kamayadi. Muhammad Khodjaev"
  },
  "csharp/task-yoki-valuetask.html": {
    "href": "csharp/task-yoki-valuetask.html",
    "title": "Task yoki ValueTask? | wahidustoz",
    "summary": "Task yoki ValueTask? Task va uning jenerik sherigi Task<TResult> klasi ancha vaqtlardan beri bor va har bir .NETchi asinxron dasturlash uchun uni ishlatib ko’rgan. .NET Core 2.0dan boshlab yangi klas ValueTask va ValueTask<TResult> olib kirildi. Ho’sh siz ulardan qaysi birini ishlatishingiz kerak? Qisqa qilib aytganda, agarda siz kutubxona yozayotgan bo’lsangiz va shu kutubxona xotirani va resurslarni judayam kam sarflashi zarur bo’lgan joylarda ishlatilsa, siz ValueTask haqida bosh qotirsangiz arziydi. Lekin ValueTask ishlatishda judayam extiyotkor bo’lish kerak. Odatiy kunlik ishlarda esa Senior darajada bo’lmagan dasturchilar Task klasi ishlatgani ma’qul. Ushbu postni oxirigacha o’qib tushinib olganingizdan keyin darajangizdan qatiy nazar ValueTask va Taskni qayerda va qanday ishlatishni tushinib olasiz. Task/Task<TResult> Task klasining vaziflari ko’p. Qisqa qilib aytganda u uzoq vaqt davom etadigan ish qaytaradigan ma’lumotni o’rash uchun wrapper sifatida ishlatiladi va promise ya’ni va’da deyiladi. Qaytarilgan Task obyektini hohlagan vaqtda await qilib kutib turgan holda natijasini olsa bo’ladi. Bundan tashqari shu obyektni hohlagancha qayta-qayta yoki parallel bir nechta threadda await qilsa ham bir xil natija qaytaradi. Bu judaham kuchli yechim! async Task<int> GetNaturalGasPriceInUsdAsync() { await Task.Delay(1000); return 9; } var uzbekNaturalGasPrice = GetNaturalGasPriceInUsdAsync(); var price = await uzbekNaturalGasPrice; var price2 = await uzbekNaturalGasPrice; Yuqoridagi kodda ko’rinib turibdiki bitta Task obyektini bir necha marta await qilish mumkin va u bir xil natija qaytaradi. Muammo Unda muammo nimada? Gap shundaki, Task va Task<TResult> klas tiplar bo’lib har safar asinxron funksiya chaqirilganda Task yoki Task<TResult> allocate (xotirani o’zlashtirish) qilib qaytarishga to’g’ri keladi. Hullas, har safar funksiya chaqirilganda yangi instance yaratib qaytarish dastur tezligi va xotira samaradorligiga sezilarli ta’sir qiladi. Runtimedagi yechimlar Ko’p hollarda asinxron funksiyalar sodda bo’ladi va ularni bir marta await orqali chaqirish kifoya bo’ladi. ... await SendEmailAsync(email, cancellationToken); ... Bundan tashqari, ko’p hollarda asinxron funksiya ham ishini sinxron tugatadi ya’ni quyidagi misoldagidek ma’lum shartlar bajarilsagina asinxron ish bajariladi yo’qsa funksiya ishini sinxron tugatib Task qaytaradi. public async Task SendEmailAsync(Email email, CancellationToken cancellationToken = default) { if(email is not null) await client.SendEmailAsync(email, cancellationToken); logger.LogInformation(\"Email not sent!\"); } Ushbu koddan tushinish mumkinki ba’zi hollarda funksiya hech qanday asinxron ish bajarilmaydi. Bunday holatlar juda ham ko’p takrorlangani uchun .NET Runtime o’zi Taskning hech qanday asinxron ish bajarilmaganda qaytariladigan nusxasini Cache qilib oladi va qayta-qayta ishlataveradi. Bu o’sha biz bilgan Task.CompletedTask obyekti. Yuqoridagi kodda agar email null bo’lsa Runtime o’zi Task.CompletedTaskni cachedan olib qaytaradi. Agar asinxron ish bajarilsa, yangi Task obyekti allocate qilib qaytariladi. Yana bir misolga qarang. Bir Task<bool> qaytaradigan funksiya bor. Bu funksiyada 3 xil holat bor: darxol sinxron true qaytaradi darxol sinxron false qaytaradi asinxron ravishda uzoq vaqtda true yoki false qaytaradi. Dastlabki ikki holatda Task<bool>dan yangi obyekt allocate qilib qaytarish shart emas. 2 ta dona qiymat bo’lgani uchun Runtime ularni allaqachon Cache saqlab qo’ygan bo’ladi va o’shalarni qaytaradi. Ya’ni yangi xotira allocate qilinmaydi. Agar funksiya asinxron ish bajarsa, majburan Task<bool> obyekti allocate qilinadi. Quyidagi snippet shuni ko’rsatadi. public async Task<bool> ShouldSendEmailAsync(User user, CancellationToken cancellationToken = default) { if(user is null) return false; if(user.IsNew()) return true; return await IsNotAdminAsync() } Lekin hamma narsani ham Cache qilish practical yechim emas. Masalan, Task<int> qaytaradigan funksiyani hamma bo’lishi mumkin bo’lgan natijalarni Cacheda saqlash Gigabaytlab xotira talab qiladi. Ko’plab kutibxonalar shunday Cache texnikasidan foydalanib yangi obyektlar yaratilishini oldini olishadi. Masalan, MemoryStream.ReadAsync funksiyadi Task<int> obyekti orqali nechta bayt o’qilganini qaytaradi. Bu funksiya ko’pincha bir xil son qaytargani uchuni ichkarida birinchi qaytarilgan Task<int> obyekti Cache qilinadi. Keyingi safar chaqirilganda, agar yana o’shancha bayt o’qigan bo’lsa eski Cache qilingan obyekt qaytariladi. Yo’qsa Task.FromResult ishlatib yangi obyekt yaratiladi. Bu funksiya .NET yangi versiyalarida ValueTask<int> qaytaradigan qilib update qilingan. ValueTask<TResult> Yuqoridagi yechimni yanada takomillashtirish uchun .NET Core 2.0dan boshlab ValueTask<TResult> struct tanishtirildi. U asinxon funksiyalardan qaytariladi va TResult yoki Task<TResult> uchun wrapper vazifasini bajaradi. Agar asinxron funksiya muvaffaqiyatli sinxron yakunlansa, ValueTask<TResult> structi TResult ga initialize qilib qaytarialdi. Hech qanday allocation bo’lmaydi. Agar asinxron yakunlansa yoki qandaydir exception sodir bo’lsa, yangi Task<TResult> obyekti allocate qilib ValueTask<TResult>ga o’rab qaytariladi. Buning yordamida yuqorida keltirilgan MemoryStream.ReadBytes funksiyasi quyidagicha takomillashtirildi. Endi hech qanday Cache ishlatilmaydi. public override ValueTask<int> ReadAsync(byte[] buffer, int offset, int count) { try { int bytesRead = Read(buffer, offset, count); return new ValueTask<int>(bytesRead); } catch (Exception e) { return new ValueTask<int>(Task.FromException<int>(e)); } } Muhim narsa qolib ketyapti await dasturlash yo’lining eng muhim xususiyatlaridan biri bu asinxron operatsiya yakunlanganda chaqirish imkonini beruvchi callback method bilan ta’minlash. Ya’ni Task/Task<TResult> qaytaradigan asinxron funksiyalarga ish tugatilganda chaqiriladigan callback method bersangiz bo’ladi. async Task<ZipArchive> CreateZipArchiveFromCloudFiles() { var files await DownloadAllFilesToTempFolderAsync(); return await CreateZipAsync(files); } var zipArchive = await CreateZipArchiveFromCloudFiles() .ContinueWith(async (task) => { await CleanupTempFolderAsync(); }); Buni amalga oshirish uchun xotirada shu operatsiyani aks ettiruvchi obyekt saqlanishi kerak va u orqali callback method chaqirilishi kerak. Shu hususiyatni ta’minlash uchun .NET Core 2.1dan boshlab IValueTaskSource<TResult> interface tanishtirildi. Bu interface asinxron operatsiya holati haqida ma’lumot saqlaydi va OnCompleted methodi orqali unga yuqoridagidan callback method bersa bo’aldi. *IValueTaskSource<TResult> haqida keyingi postlarda.* Endi ValueTask<TResult> va ValueTask structlari birgalikda asinxron funsiyalarni har qanday holatda ham hech qanday hotira allocate qilmasdan natija qaytarish imkonini beradi. ValueTask ishlatishdagi havf ValueTask va ValueTask<TResult> qisqa qilib aytganda oddiy holatlarda bir marta await qilib ishlatiladigan Tasklar uchun chiqarilgan. Quyidagi holatlarda hech qachon ValueTask / ValueTask<TResult> ishlatmaslik kerak. ValueTask / ValueTask<TResult> ni bir martadan ortiq await qilish. ValueTask<TResult> ichidagi TResult obyekti GC tomonidan recycle qilib yuborilgan bo’lishi yoki boshqa operatsiya tomonidan ishlatilayotgan bo’lishi mumkin **ValueTask / ValueTask<TResult>**ni bir vaqta bir nechta threaddanawait qilish. Yuqoridagiday TResult obyekti bitta thread ishini tugatgach recycle qilib yuborilgan bo’lishi mumkin. Operatsiya yakunlanmasidan avval .GetAwaiter().GetResult() funksiyasi orqali blok qilib natijani kutish. IValueTaskSource va IValueTaskSource<TResult> interfacelari blok qilish imkoniyatini bermaydi. Agar sizga yuqoridagi imkoniyatlar chindan ham zarur bo’lsa, .AsTask() methodi orqali ValueTask/ValueTask<TResult> larni Taskga aylantirib olsangiz bo’ladi. Ushbu maqolada qandaydir xatolik topsangiz habar bering. Wahid Abduhakimov"
  },
  "dotnet/aspnetcore-8.html": {
    "href": "dotnet/aspnetcore-8.html",
    "title": "ASP.NET Core 8.0 | wahidustoz",
    "summary": "ASP.NET Core 8.0 ASP.NET Core nima ekanini yoddan chiqarganlar uchun eslatib o'taman, bu .NET Frameworkni asosan web texnologiyalari uchun javobgar qismi. ASP.NET Core 8 web va server texnologiyalari samaradorligini oshiradigan minglab performance improvement va yangi featurelar taqdim etdi. Blazor \uD83D\uDD25 .NET 8 versiyasidan boshlab Blazor endi to'laqonli Web UI frameworkga aylandi. U orqali sayt kontentlarini page yoki component levelida qayta render qilsa bo'ladi. Blazor avval 2 xil versiyaga ega edi. Server UI elementlari serverda render qilinib kerakli vaqtda SignalR orqali o'zgargan elementlargina klientga yuboriladi. bu birinchi parta saytni tortishda juda tez lekin juda katta server resurslari talab qiladi WASM UI elementlari to'liqligicha klient brauzerida render bo'ladi. birinchi marta saytni tortib olishga uzoq vaqt ketadi. serverdagi havfsizlik va boshqa server imkoniyatlari mavjud emas Blazor app yasashdan avval 2ta tanlovdan birini tanlashga to'g'ri kelar edi va butun sayt bo'ylab yoki Server yoki WASM rejimda ishlar edi. \uD83D\uDCE2 Endi Blazor render turini global sayt bo'yicha emas Page/Component levelida boshqarsa bo'ladi. Blazorni yangi Hybrid vesiyasida istalgan Component yoki Pageni server/wasm render bo'lishini boshqarsa bo'ladi. Bu orqali saytni birinchi marta tortib olish yorug'lik tezligida bo'ladi va unda keyin barcha renderin brauzerda WASM usulida amalga oshiriladi. Bundan tashqari Blazorda yana yuzlab yangiliklar bor. Ularni bu yerda o'qib oling. \uD83C\uDFA5 Batafsil mana bu yerda 2X tezlikda ko'rib oling! Minimal API \uD83D\uDE09 .NET 8dagi qo'shimchalarning ko'p qismi Native AOT va Source Generatorlar bilan bog'liq. Ular compile time vaqtida kerakli kodlarni generate qiladi va bu orqali runtime performance sezilarli oshiriladi. Form binding Avvalgi versiyalarida IFormFile va IFormCollection orqali form elementlariga erishish imkoni bor edi. Lekin MVC Controllerlar kabi [FromForm] attribute orqali form elementlarini Model objectga bog'lashni iloji yo'q edi. .NET 8 Minimal API endi bu ishni qila oladi. app.MapPost(\"/register\", async([FromForm] RegisterModel model) => { // register logic }); Mana bu postda bu haqida batafsil! Native AOT Support Native AOT orqali publish qilingan dasturlarni hajmi juda kichi bo'ladi, ular juda tez ishga tushadi va juda ham kam RAM talab qiladi. Bu yerda batafsil o'qing! Wahid Abduhakimov"
  },
  "dotnet/dotnet-8.html": {
    "href": "dotnet/dotnet-8.html",
    "title": ".NET 8 \uD83C\uDF89 | wahidustoz",
    "summary": ".NET 8 \uD83C\uDF89 Qaynoqqina yangilik, .NET Foundation yaqindagina .NET SDK 8ni ommaga taqdim etdi. Ushbu post orqali undagi eng qiziqarli o'zgarishlar va yangiliklar bilan tanishamiz. .NET 8 SDK yuklash Avvalo .NET 8ni o'rnatishdan boshlaymiz. Quyidagi powershell komandasini tering. winget install Microsoft.DotNet.SDK.8 Tip Menga o'xshab Nerd bo'lmaganlar \uD83D\uDC49 shu link orqali o'zlariga kerakli installerni tortib olishlari mumkin. Tip C# 12 bilan bog'liq yangiliklarni bu yerda o'qing! Tip ASP.NET Core 8.0 bilan bog'liq yangiliklarni bu yerda o'qing! ⚠️ Har bir yangi qo'shilgan Feature ustida batafsil postlarni shu yerda berib boraman. Yangiliklardan qolib ketmaslik uchun Telegram kanalimga obuna bo'ling! Wahid Abduhakimov"
  },
  "dotnet/entity-model-dto.html": {
    "href": "dotnet/entity-model-dto.html",
    "title": "DTO, Model va Entity | wahidustoz",
    "summary": "DTO, Model va Entity Nega bir obyekt o'rniga uchta kerak? \uD83E\uDD14 Tasdavvur qiling, siz bir xonadonda yashab, o'sha joyda ishlaysiz va mehmonlarni ham shu yerda qabul qilasiz. Tabiiyki, tartib bir oz buziladi, to'g'rimi? \uD83C\uDF89 Entity, Model va DTOlarni ajratmaslik ham shunga o'xshaydi. Ularni birga ishlatsangiz, kod ham chalkashadi, ham o'qish qiyin bo'lib qoladi. Har biri o'z vazifasini bajarsa, kodni tushunish osonroq bo'ladi va har bir qatlam (API, biznes logika, ma'lumotlar bazasi) o'ziga xos mantiqda ishlaydi. \uD83C\uDFAF Ular o'zi nima? \uD83E\uDD37‍♂️ Term Definition DTO Ma'lumotlarni uzatish obyekti (DTO) — bu ilovaning qatlamlari o'rtasida ma'lumotlarni uzatish uchun ishlatiladigan yengil ob'ekt. Model Ilovangiz ichida ishlatiladigan ma'lumotlar tuzilmasini ifodalaydi, ko'pincha biznes mantiqiga yaqin. Entity Sizning saqlash qatlamingizdagi ma'lumotlar bazasi jadval tuzilmasini ifodalaydi, odatda EF Core kabi ORM bilan bog'liq. Asosiy Farqlar graph TD; Entity-->Database[\"Ma'lumotlar Bazasi Jadvali\"]; Model-->BusinessLogic[\"Biznes Mantiqi\"]; DTO-->API[\"Mijoz yoki API Bilan O'zaro Ta'sir\"]; Entitylar ma'lumotlar bazasi bilan o'zaro ta'sir qilish uchun ishlatiladi va jadvallardagi qatorlarni ifodalaydi. Modellar ilovangiz ichida ma'lumotlarni qanday qayta ishlashini belgilaydi. DTOlar qatlamlar o'rtasida yoki tashqi mijozlarga to'g'ri ma'lumotlarni uzatishga e'tibor qaratadi. Entity nima? \uD83D\uDCE6 Entity — bu sizning ma'lumotlar bazasidagi jadvalning aksidir. Ya'ni, har bir qatorni obyekt ko'rinishida tasvirlaydi. /// <summary> /// Ma'lumotlar bazasidagi Book jadvali uchun Entity. /// </summary> namespace Ilmhub.Api.Entities; public class Book { public int Id { get; set; } public string Title { get; set; } public string Author { get; set; } public decimal Price { get; set; } public DateTime PublishedDate { get; set; } } Note Entity bilan bevosita API yoki biznes qatlamida ishlash tavsiya etilmaydi. Chunki bu xavfsizlik va moslashuvchanlikni kamaytiradi. Model nima? \uD83D\uDEE0️ Model — bu biznes logikaga mos keladigan ma'lumotni tasvirlash uchun ishlatiladi. Ko'pincha validatsiya yoki ma'lumotni qayta ishlash uchun kerak bo'ladi. /// <summary> /// Ilovadagi ma'lumotni qayta ishlash uchun Model. /// </summary> namespace Ilmhub.Api.Models; public class Book { public string Title { get; set; } public string Author { get; set; } public decimal Price { get; set; } } Tip Model — bu qahvaxona ichidagi menyu: tashqi mijozlar uni ko'rmaydi, lekin u asosiy faoliyatni boshqaradi. ☕ DTO nima? \uD83D\uDE9A DTO (Data Transfer Object) — bu ma'lumotni tashqi dunyoga (API mijozlariga) jo'natish uchun eng qulay shaklga keltirilgan obyekt. /// <summary> /// API uchun DTO. /// </summary> namespace Ilmhub.Api.Dtos; public class Book { public string Title { get; set; } public string Author { get; set; } } Note DTO ma'lumotni minimal miqdorda va xavfsiz shaklda yetkazish uchun ishlatiladi. Ya'ni, \"bu yerda faqat kerakli narsani oling\" tamoyiliga asoslanadi. \uD83D\uDEE1️ Mapperlar va ularning ahamiyati ✨ Mapperlar — bu ma'lumotni bir obyekt turidan ikkinchisiga avtomatik ravishda o'zgartiruvchi sehrli vosita. \uD83C\uDFA9\uD83D\uDC07 Tasavvur qiling, qo'lda har bir Entityni DTOga aylantirasiz: bu matematika muammosiday gap! Mapperlar esa buni avtomatlashtirib, hayotingizni yengillashtiradi. AutoMapper misoli var configuration = new MapperConfiguration(cfg => { cfg.CreateMap<Entities.Book, Dtos.Book>(); cfg.CreateMap<Models.Book, Entities.Book>(); }); var mapper = configuration.CreateMapper(); // Entity'dan DTO yaratish: var dto = mapper.Map<Dtos.Book>(entity); Tip Mapperlar ishlashda vaqtni tejaydi va kamroq xato qilishga yordam beradi. \uD83D\uDD27⏳ Hammasi Minimal API-da qanday ishlaydi? \uD83E\uDDE9 Quyida Entity, Model, DTO va Mapperlar birgalikda qanday ishlashini ko'rsatamiz: var builder = WebApplication.CreateBuilder(args); var app = builder.Build(); // Misol uchun: xotira ichida ma'lumotlar bazasi var books = new List<Entities.Book> { new Entities.Book { Id = 1, Title = \"C# in Depth\", Author = \"Jon Skeet\", Price = 39.99M, PublishedDate = DateTime.Now } }; // Mapper sozlash var configuration = new MapperConfiguration(cfg => { cfg.CreateMap<Entities.Book, Dtos.Book>(); cfg.CreateMap<Models.Book, Entities.Book>(); }); var mapper = configuration.CreateMapper(); // Barcha kitoblarni olish (DTO shaklida) app.MapGet(\"/books\", () => { return books.Select(book => mapper.Map<Dtos.Book>(book)); }); // Yangi kitob qo'shish (Model orqali) app.MapPost(\"/books\", (Models.Book model) => { var newBook = mapper.Map<Entities.Book>(model); newBook.Id = books.Count + 1; newBook.PublishedDate = DateTime.Now; books.Add(newBook); return Results.Created($\"/books/{newBook.Id}\", newBook); }); app.Run(); Xulosa \uD83D\uDE80 Entity — ma'lumotlar bazasini aks ettiradi. Model — biznes logikani boshqaradi. DTO — mijoz bilan aloqani soddalashtiradi. Mapperlar esa ularning barchasini birlashtirib, hammasini zavq bilan boshqarishga imkon beradi. \uD83D\uDE0E Kodda tartib va chiroyli arxitektura — bu haqiqiy \"pro\" bo'lishning kaliti! \uD83D\uDD11 Wahid Abduhakimov"
  },
  "dotnet/fluent-validation.html": {
    "href": "dotnet/fluent-validation.html",
    "title": "FluentValidation | wahidustoz",
    "summary": "FluentValidation Maqolani boshlashdan avval validatsiya o’zi nima ekanligi haqida bir og’iz: Validatsiya — bu, ma'lumotlarni saqlash yoki ishlashdan avval, belgilangan qoidalarga va cheklovlarga muvofiqligini tekshirish jarayonidir. .NET’da ma’lumotlarni to’g’riligini tekshirishning (endi validatsiya deb yuritiladi) bir nechta yo’llari mavjud. Masalan ulardan biri bu Data Annotation (batafsil:). Va yana biri esa qo’shimcha package yordamida validatsiya qilish. Ushbu maqolada Data Annotation usuli bilan emas balki FluentValidation (batafsil) package’i orqali validatsiyani amalga oshirishni ko’rib chiqamiz. Kettik! Nega Data Annotation emas, Fluent Validation? Xususiyat Fluent Validation Data Annotation Sintaksis & O‘qishga qulayligi Qiyin logikalar uchun oson, yaxshiroq o‘qiladi Attribut orqali e’lon qilinadi Testga oson/qiyinligi Unit test’lar uchun oson, chunki validatsiyalar qismi alohida klasslarda bo‘ladi Test qilish uchun qiyinroq, chunki validatsiya qismlari alohida klassda emas balki Model class’ni o‘zida e’lon qilinadi Qayta ishlatish mumkin yoki yo‘q Beeemalol qayta ishlatsa bo‘ladi ya’ni validatsiya qismlari alohida klassda bo‘lganligi bois ularni turli xil project’lar-aro ishlatsak bo‘ladi Modelda to‘g‘ridan-to‘g‘ri e’lon qilinganligi sababli, qayta ishlatish murakkabroq Xatoliklar haqida xabar berishi O‘zimiz xohlagancha Error message’lar berishimiz mumkin Bazaviy (odatiy) error xabarlar. FluentValidation — ishni boshlaymiz Avval o’rnatib olamiz: dotnet add package FluentValidation Validatorlar e’lon qilamiz Bizga AbstractValidator<T>’dan meros oluvchi bitta class kerak bo’ladi va u class’ni ichiga ma’lumotlar uchun qoidalar/ma’lumotlar yozamiz. AbstractValidator<T> FluentValidation’dan keladi. Kettik: using FluentValidation; public class UserValidator : AbstractValidator<User> { public UserValidator() { RuleFor(user => user.Name) .NotEmpty() .WithMessage(\"Ismni kiritish majburiy!\"); RuleFor(user => user.Email) .EmailAddress() .WithMessage(\"Iltimos to'g'ri pochta manzilini kiriting!\"); RuleFor(user => user.Age) .InclusiveBetween(18, 60) .WithMessage(\"Yoshingiz 18 dan oshgan va 60 dan kichik bo'lishi kerak!\"); } } Demak AbstractValidator<T> ni ichiga biz cheklovlar o’rnatmoqchi bo’lgan Model Class’imizni nomini berib yuborar ekanmiz. Metodni ichida RuleFor kalit so’zi orqali turli-xil cheklovlar qo’ysak bo’ladi. WithMessage() orqali biz o’zimiz xohlagan error message’larni berib yuborsak bo’ladi. Aslida bermasak ham error message ko’rsatadi lekin o’zinikini ko’rsatadi ya’ni masalan “user.Name mustn’t be null” bo’lishi mumkin. Ma’lumotni validator orqali tekshirish Yuqorida ochgan class’imizga instance ochamiz va uni ichida Validate() degan method bor. Usha bilan ma’lumotimiz biz o’rnatgan qoidalarga tushadimi yo’qmi tekshiramiz: var user = new User { Name = \"\", Email = \"invalid\", Age = 17 }; var validator = new UserValidator(); var result = validator.Validate(user); if (!result.IsValid) { foreach (var error in result.Errors) { Console.WriteLine($\"{error.PropertyName}: {error.ErrorMessage}\"); } } Demak Validate() method’i ichiga biz tekshirmoqchi bo’lgan ma’lumotlarimizni beramiz va uni biz o’rnatgan qoidalarga tushadimi yo’qmi tekshirib javobni result o’zgaruvchisiga solib qo’yadi. Uni ichida esa isValid bor va u bool qaytaradi. Agarda false bo’lsa demak biz o’rnatgan shartlar qanoatlantirilmagan bo’ladi. Tamom, Fluent Validation’ni oddiy ishlatilinishi shu qadar. Fluent Validation’ni murakkabroq ishlatish Yuqorida biz oddiy ishlatishni ko’rib chiqdik. U yerda bor narsalardan foydalandik ya’ni masalan: RuleFor(user => user.Name) .NotEmpty() .WithMessage(\"Ismni kiritish majburiy!\"); Masalan bu yerda .NotEmpty() method’i o’zi bor va u string’ni bo’sh yoki yo’qligini tekshiradi. Lekin bizga murakkabroq tekshirishlar kerak, masalan string’imiz faqatgina katta harflardan tashkil topgan bo’lishi kerak bo’lsachi, nima qilamiz??? Qoidalarga qoida qo’shish Fluent Validation’ni ichida bor method’lardan tashqari o’zimiz ham qoidalar yozsak bo’ladi, albatta qoida yozish uchun ichidagi method’ni ishlatamiz \uD83D\uDE03: RuleFor(user => user.Password) .NotEmpty() .MinimumLength(8) .Matches(@\"[A-Z]\").WithMessage(\"Parol faqatgina katta harflardan iborat bo'lishi shart!\"); Bu yerda .Matches qilsak solishtiradi, agarda Matches shartiga tushmasa albatta bu false bo’ladi. RuleFor(user => user.ConfirmPassword) .Equal(user => user.Password) .WithMessage(\"Parollar bir-biriga o'xshashi shart!\"); Ma’lum bir ma’lumot boshqa ma’lumotga qaram bo’lishiham mumkin, masalan tasavur qiling yangi parol yozyapsiz va uni ikki martta yozasiz, ikkalasiham bir-biriga o’xshashi shart. Shunda ishlatsak bo’ladi. Murakkabroq ishlatish — loyiha talabiga qarab o’zgarib ketaveradi. Ko’proq ma’lumot olish uchun albatta FluentValidation’ning rasmiy dokumentatsiyasini o’qib chiqishni qattiq tavsiya qilaman: https://docs.fluentvalidation.net/en/latest/aspnet.html Muhammad Khodjaev"
  },
  "dotnet/ihttpclientfactory.html": {
    "href": "dotnet/ihttpclientfactory.html",
    "title": "IHttpClientFactory in .NET | wahidustoz",
    "summary": "IHttpClientFactory in .NET Bugungi maqolada IHttpClientFactory interface’i bilan qanday qilib HttpClient ochishni ko’rib chiqamiz. Buni amalga oshirishda bizga Dependency Injection (DI) yordamga keladi. Aslida IHttpClientFactory .NET Core 2.1 (May 30, 2018) da chiqqan. Biz bu interface bilan HttpClient yaratsak nima afzalliklari bo’ladi degan savol tug’ilishi tabiiy albatta. Agarda IHttpClientFactory bilan HttpClient ochadigan bo’lsak biz unga o’zimiz hohlagancha configuration bersak bo’ladi. Давайте gapni cho’zmasdan bu interface haqida batafsil gaplashishni boshlaymiz, kettik \uD83D\uDE80. IHttpClientFactory o’zi nima? Yuqorida ta’kidlaganimdek, IHttpClientFactory bilan biz HttpClient ochsak bo’ladi, xo’sh buning nima afzalliklari bor, oddiy ochib ishlatib ketursam bo’lmaydimi degan savol tug’ilishi mumkin. Quyida qachonki biz AddHttpClient qilib servisni registratsiyadan o’tkazsak, biz quyidagi afzalliklarga ega bo’lamiz: HttpClient ni DI (Dependency Injection)’ga tayyor qo’shib qo’yadi. Turli-xil API’lar uchun HttpClientlarni nomlab qo’ysak bo’ladi. HttpClientning umrini (lifetime) boshqarishga yo’l ochiladi. Log qo’shish imkonini beradi. IHttpClientFactory ishlatilishi Bizda bir-nechta вариант’lar bor: Oddiy ishlatilinishi (Basic usage) Nomlash orqali ishlatish (Named clients) Turlash orqali ishlatish (Typed Clients) Bular orasidan eng zo’ri esa dastur nimani talab qilayotganidan kelib chiqilgan holda aniqlanadi. Bularni esa birma-bir ko’rib chiqamiz, ketti: \uD83D\uDE80 Oddiy ishlatilinishi (Basic usage) IHttpClientFactoryni servis ichiga qo’shish uchun AddHttpClientni chaqiramiz: using httpclient; HostApplicationBuilder builder = Host.CreateApplicationBuilder(args); builder.Services.AddHttpClient(); builder.Services.AddTransient<TodoService>(); using IHost host = builder.Build(); Va uni qanday qilib TodoService.cs da chaqirishni ko’ramiz: using System.Net.Http.Json; using System.Text.Json; using Microsoft.Extensions.Logging; namespace httpclient; public sealed class TodoService( IHttpClientFactory httpClientFactory, // Bu yerda IHttpClientFactoryni inject qilamiz ILogger<TodoService> logger) { public async Task<Todo[]> GetUserTodosAsync(int userId) { using HttpClient client = httpClientFactory.CreateClient(); // Client ochamiz try { Todo[]? todos = await client.GetFromJsonAsync<Todo[]>( $\"https://jsonplaceholder.typicode.com/todos?userId={userId}\", new JsonSerializerOptions(JsonSerializerDefaults.Web)); // Va uni ishlatamiz return todos ?? []; } catch (Exception ex) { logger.LogError(\"Error getting something fun to say: {Error}\", ex); } return []; } } Shu qadar, tamom. Mana shunday qilib oddiygina HttpClient ochib uni ishlataveramiz, hech kim hech qanday mo’nelik bildirmaydi. Nomlash orqali (Named Clients) HttpClientni nomlash orqali ishlatish bizga bir xolatda kerak bo’ladi: Bir-nechta HttpClientlar bir necha xil configuration bilan kerak bo’lib qolganda. Hop, lekin qanday qilib HttpClientga configuration qo’shish mumkin? Uni servislarga registratsiya qilayotganda (asosan Program.cs’da) qo’shib ketamiz: builder.Services.AddHttpClient(\"Private\", client => client.BaseAddress = new Uri(builder.HostEnvironment.BaseAddress)) .AddHttpMessageHandler<BaseAddressAuthorizationMessageHandler>(); builder.Services.AddHttpClient(\"Public\", client => client.BaseAddress = new Uri(builder.HostEnvironment.BaseAddress)); Ushbu misolda biz HttpClientni nomini Private va Public qilyapmiz va qachonki biz HttpClient Public nomi bilan chaqirganimizda bizga aynan shu configuration bilan HttpClient ochiladi, tamom. public class SomeService( HttpClient client, IHttpClientFactory clientFactory, JsonSerializerOptions jsonOptions) : ISomeService { public async Task<Something?> GetByNumberAsync( string number, bool usePrivateClient = false, CancellationToken cancellationToken = default) { var httpClient = client; if (usePrivateClient is false) httpClient = clientFactory.CreateClient(\"Public\"); var item = await httpClient.GetFromJsonAsync<Something>( $\"api/certificates/{number}\", jsonOptions, cancellationToken); return item; } } Va ushbu misolda Something degan nimadurni idsi orqali olishi kerak ekan va qachonki biz oddiy HttpClient chaqirsak u bizga doim Private bo’lib keladi, lekin biz aynan shu method ni ichida Public qilinganini chaqirmoqchimiz, shunchaki tekshirib agarda Private bo’lsa Public bo’lganini olyabmiz, tamom. Shunda Public qilib nomlangan Configuration li HttpClientimiz ishlaydi. Turlash orqali (Typed client) Nomlash turi (named client) bilan deyarli bir-xil imkoniyatlar beradi. IntelliSense’ni bilan ta’minlaydi. Servisga registratsiya qilingan HttpClient faqatgina bir joyda ishlatilinadi va usha servisga registratsiya paytida Configure qilsak bo’ladi. Demak u nomidan kelib chiqadigan bo’lsakham turlangan client ekan: Demak bir dona backend endpoint uchun ishlaydi. Servisga registratsiya qilindimi demak DI sharofati bilan dasturimizning istalgan joyida inject qilib ishlatib keta olamiz. Shunchaki buni Program.csda servisga registratsiya qilayotganimizda aynan qaysi servis uchun bu client ishlashini berib ketishimiz kerak shunda u Typed Client bo’ladi: builder.Services.AddHttpClient<TodoService>( client => { client.BaseAddress = new Uri(\"https://jsonplaceholder.typicode.com/\"); client.DefaultRequestHeaders.UserAgent.ParseAdd(\"dotnet-docs\"); }); Bu yerda e’tibor bersangis AddHttpClientni ichiga TodoService ni berib yuboryapmiz. Va client.DefaultRequestHeaders.UserAgent.ParseAdd(\"dotnet-docs\"); bu qism esa headerga “dotnet-docs” yozuvini qo’shib qo’yadi. Turlash (typed client)lar Transient sifatida DI (dependency injection) ga qo’yiladi. POST, PUT va DELETE uchun request Yuqoridagi misollarda faqatgina GET uchun misol keltirilgan, ammo HttpClient boshqa turdagi HTTP amallariniham bajara oladi: POST PUT DELETE PATCH Va boshqalar Muhammad Khodjaev"
  },
  "dotnet/index.html": {
    "href": "dotnet/index.html",
    "title": "| wahidustoz",
    "summary": ".NET and ASP.NET related posts Here you will discover an extensive array of the most recent news, cutting-edge features, and essential updates for .NET. \uD83D\uDCF0 ✨ Logging Levels (and how to use them) Logging Code Generators .NET 8 ASP.NET Core 8.0 Dto, Model va Entity Middleware FluentValidation IHttpClientFactory"
  },
  "dotnet/log-code-gen.html": {
    "href": "dotnet/log-code-gen.html",
    "title": "Improve logging performance with code generation | wahidustoz",
    "summary": "Improve logging performance with code generation Avvalgi postda logging levels __(logging darajalari)__ni tushintirib bergan edim. Bugun logging tezligini oshirish uchun taklif etilayotgan yangi feature Logging Code Generation haqida gaplashamiz. Code generation bu yangilik emas. Avvaldan Blazor, Razor va shunga o'xshash engine'lar compile vaqtida kod generate qiladi. .NET 6 versiyasida olib kirilgan yangi attribute LoggingMessageAttribute bo'lsa aynan Logging samaradorligini oshirish uchun compile vaqtida reusable logging funksiyalari yaratish uchun ishlatiladi. Ushbu qo'shimcha haqida batafsil bu yerda o'qishingiz mumkin. Logging Code generation ishlatish uchun static partial klas yaratib uni ichida partial kalit so'zi orqali methodlar elon qilishingiz kerak. Bu methodlarni tanasi compile vaqtida .NET tomonidan yaratiladi va qayta ishlatiladi. public static partial class ValidationFilterLoggings { [LoggerMessage( EventId = 0, Level = LogLevel.Trace, Message = \"Fluent validation started for type {targetType}.\")] public static partial void LogValidationStarted( this ILogger logger, string targetType); } E'lon qilingan funksiyani tanasi compile vaqtida .NET tomonidan yaratiladi. Keyin ushbu logging methodni quyidagicha ishlatsa bo'ladi. public class AsyncFluentValidationFilter<T> : IEndpointFilter where T : class { private readonly ILogger<AsyncFluentValidationFilter<T>> logger; public AsyncFluentValidationFilter(ILogger<AsyncFluentValidationFilter<T>> logger) => this.logger = logger; public async ValueTask<object> InvokeAsync(EndpointFilterInvocationContext context, EndpointFilterDelegate next) { ... logger.LogValidationStarted(nameof(T)); ... } } Note Yuqorida elon qilingan LogValidationStarted funksiyasi ILogger interface ustiga qurilgani uchun, bu methodni istalgan ILogger interface obyektida ishlatsa bo'ladi. Agar sizga maxsus bitta generic ILogger<T> ustida ishlaydigan mehod kerak bo'lsa, this ILogger<T> shaklida elon qilishingiz kerak. Misol uchun quyidagi kodga qarang \uD83D\uDC40 public static partial class ValidationFilterLoggings { [LoggerMessage( EventId = 1, Level = LogLevel.Trace, Message = \"Fluent validation for {targetType} is successful.\")] public static partial void LogValidationCompleted( this ILogger<AsyncFluentValidationFilter<T>> logger, string targetType); } Wahid Abduhakimov"
  },
  "dotnet/log-levels.html": {
    "href": "dotnet/log-levels.html",
    "title": "Logging Levels | wahidustoz",
    "summary": "Logging Levels Logging dasturni eng muhim qismlaridan biri hisoblanadi. Ko’pchilik unga katta e’tibor bermasa ham Logging to’g’ri qilinmasa juda katta mablag’ va vaqt yo’qotilishiga olib kelishi mumkin. Odam yozgan lyuboy sistemada Bug \uD83E\uDEB2 bo’ladi. Dastur ishga tushgandan keyin kelib chiqqan xatoliklarni dasturda yozib borilayotgan Loglarsiz qidirib topishni imkoni yo’q. Bugungi postda Log Levels ya’ni log xabarlarni muhimlik darajalariga qarab qanday ishlatishni o’rganamiz. 1. Trace — logger.LogTrace() Bu turdagi loglar dastur davomidagi har bir qadamni batafsil yozib ketish uchun ishlatiladi. Yangi jarayon, funksiya, loop yoki oqim boshlanishi va tugaganidan keyin iz qoldirish uchun Trace log yozib ketiladi. public async Task ProcessOrder(CustomerOrder order) { logger.LogTrace(\"Starting order processing for OrderId: {OrderId}\", order.OrderId); // Validate the order if (IsOrderValid(order)) { logger.LogTrace(\"Order validation successful for OrderId: {OrderId}\", order.OrderId); // Perform necessary actions such as updating inventory, sending notifications, etc. logger.LogTrace(\"Persisting order with OrderId: {OrderId}\", order.OrderId); await storage.PersistOrderAsync(order); logger.LogTrace(\"Publishing OrderCreated message with OrderId: {OrderId}\", order.OrderId); await messaging.PublishOrderCreated(order); } } 2. Debug — logger.LogDebug() Bu turdagi log Tracega juda ham yaqin, lekin yagona farqi Debug log ichida o’zgaruvchilar qiymatlari batafsilroq yoritiladi. Shu sababli bu turdagi log ichida maxfiy ma’lumotlar bo’lishi mumkin. Debug va Trace log miqdori juda katta bo’lgani uchun odatda Production muhitda o’chirib qo’yish tavsiya qilinadi. Shaxsiy fikrimcha Debug yoki Trace darajasidan kamida bittasi Production muhitda ham ko’rinishi kerak. public async Task ProcessOrder(CustomerOrder order) { logger.LogTrace(\"Starting order processing for OrderId: {OrderId}\", order.OrderId); logger.LogDebug(\"Processing order: {Order}\", order); // Validate the order if (IsOrderValid(order)) { logger.LogTrace(\"Order validation successful for OrderId: {OrderId}\", order.OrderId); logger.LogDebug(\"Order validation successful for: {Order}\", order); // Perform necessary actions such as updating inventory, sending notifications, etc. logger.LogTrace(\"Persisting order with OrderId: {OrderId}\", order.OrderId); logger.LogDebug(\"Persisting order: {order}\", order); await storage.PersistOrderAsync(order); logger.LogTrace(\"Publishing OrderCreated message with OrderId: {OrderId}\", order.OrderId); logger.LogDebug(\"Publishing OrderCreated for order: {order}\", order); await messaging.PublishOrderCreated(order); } } Summary Yuqorida keltirilgan LogTrace va LogDebug odatda dasturchilar uchun yo’naltirilgan bo’ladi. Ya’ni bu turdagi loglarni odatda developerlar BUG\uD83E\uDEB2ni qidirib topish uchun ishlatishadi. 3. Information — logger.LogInformation() Bu turdagi log odatda biror katta jarayon boshlanishi va muvaffaqiyatli tugaganini ko’rsatish uchun ketiladi. Trace va Debugdan farqli o’laroq, Information turidagi xabarlar miqdori juda kam bo’ladi. Bunday log ichida iloji boricha maxfiy ma’lumotlar ko’rsatilmasligi kerak. public async Task ProcessOrder(CustomerOrder order) { logger.LogTrace(\"Starting order processing for OrderId: {OrderId}\", order.OrderId); logger.LogDebug(\"Processing order: {Order}\", order); // Validate the order if (IsOrderValid(order)) { logger.LogTrace(\"Order validation successful for OrderId: {OrderId}\", order.OrderId); logger.LogDebug(\"Order validation successful for: {Order}\", order); // Perform necessary actions such as updating inventory, sending notifications, etc. logger.LogTrace(\"Persisting order with OrderId: {OrderId}\", order.OrderId); logger.LogDebug(\"Persisting order: {order}\", order); await storage.PersistOrderAsync(order); logger.LogTrace(\"Publishing OrderCreated message with OrderId: {OrderId}\", order.OrderId); logger.LogDebug(\"Publishing OrderCreated for order: {order}\", order); await messaging.PublishOrderCreated(order); logger.LogInformation(\"Order with orderId {OrderId} successfully processed.\", order.Id); } } 4. Warning — logger.LogWarning() Warning xabarlar dasturda kutilmagan holat yoki noto’g’ri ma’lumot paydo bo’lganda qoldiriladi. Bunday holat yuz berganda dasturchi, sistema admini yoki dasturni o’zi ham hech qanday amal bajarish orqali xatoni tuzatishga urinishi shart emas. Bu xabarni muhim tarafi, sistemadagi bu kutilmagan holat keyinchalik e’tibor talab etuvchi jiddiy xatolikka olib borishi mumkin. public async Task ProcessOrder(CustomerOrder order) { logger.LogTrace(\"Starting order processing for OrderId: {OrderId}\", order.OrderId); logger.LogDebug(\"Processing order: {Order}\", order); // Validate the order if (IsOrderValid(order)) { logger.LogTrace(\"Order validation successful for OrderId: {OrderId}\", order.OrderId); logger.LogDebug(\"Order validation successful for: {Order}\", order); // Perform necessary actions such as updating inventory, sending notifications, etc. logger.LogTrace(\"Persisting order with OrderId: {OrderId}\", order.OrderId); logger.LogDebug(\"Persisting order: {order}\", order); await storage.PersistOrderAsync(order); logger.LogTrace(\"Publishing OrderCreated message with OrderId: {OrderId}\", order.OrderId); logger.LogDebug(\"Publishing OrderCreated for order: {order}\", order); await messaging.PublishOrderCreated(order); logger.LogInformation(\"Order with orderId {OrderId} successfully processed.\", order.Id); } else { logger.LogDebug(\"Validation failed for order {order}\", order); // batafsil ma'lumot qoldirish uchun logger.LogWarning(\"Validation failed for order with id: {OrderId}\", order.Id); logger.LogDebug(\"Publishing OrderFailed for order: {order}\", order); await messaging.PublishOrderFailed(order); } } 5. Error — logger.LogError() Error xabarlar biror katta yumush bajarish jarayonida xatolik yuz berib shu funksiya oxiriga yeta olmasa qoldiriladi. Error xabar qoldirilish shu jarayon oxiriga yetmay qolganini lekin sistemaning boshqa qismlariga ta’sir qilmasligini anglatadi. Odatda Error xabarlarni sistemani o’zinig Error Handling, Retry mexanizmlari bartafar qiladi. Ayrim hollarda operatorlar ma’lumot xolatini o’zgartirish orqali ham bu Error holatdan chiqib ketishlari mumkin. Error xabar yuz berganda Operatorlar yoki dasturchilar uyqularidan turib bo’lsa ham shu xatolikni bartaraf etishlari kerak. Shuning uchun bu turdagi xatoliklarni log qilishda shoshilmaslik kerak. Operator va dasturchini uyqusini buzishga arziydimi degan savolni berish kerak. public async Task ProcessOrder(CustomerOrder order) { logger.LogTrace(\"Starting order processing for OrderId: {OrderId}\", order.OrderId); logger.LogDebug(\"Processing order: {Order}\", order); // Validate the order if (IsOrderValid(order)) { logger.LogTrace(\"Order validation successful for OrderId: {OrderId}\", order.OrderId); logger.LogDebug(\"Order validation successful for: {Order}\", order); try { // Perform necessary actions such as updating inventory, sending notifications, etc. logger.LogTrace(\"Persisting order with OrderId: {OrderId}\", order.OrderId); logger.LogDebug(\"Persisting order: {order}\", order); await storage.PersistOrderAsync(order); logger.LogTrace(\"Publishing OrderCreated message with OrderId: {OrderId}\", order.OrderId); logger.LogDebug(\"Publishing OrderCreated for order: {order}\", order); await messaging.PublishOrderCreated(order); } catch(DbException ex) { logger.LogError(\"Order processing failed for order with id: {OrderId}\", order.Id); throw new OrderProcessingFailedException(order, ex); } logger.LogInformation(\"Order with orderId {OrderId} successfully processed.\", order.Id); } else { logger.LogDebug(\"Validation failed for order {order}\", order); // batafsil ma'lumot qoldirish uchun logger.LogWarning(\"Validation failed for order with id: {OrderId}\", order.Id); logger.LogDebug(\"Publishing OrderFailed for order: {order}\", order); await messaging.PublishOrderFailed(order); } } 6. Critical — logger.LogCritical() Bunday Log sistemani barcha qismlarini ishdan chiqaruvchi xatolikni yozish uchun ishlatiladi. Masalan, RAM yoki SSD xotira tugab qolishi, butun dastur bo’ylab Database’ga bog’lana olmaslik yoki shunga o’xshash dastur ishlashi uchun so’zsiz kerak resursni yo’qligi. Bunday xatoliklar dastur davomida bir marta yuz beradi. Ya’ni Critical error yuz bergandan keyin dastur o’chib qolishi va Sistem adminstrator tomonidan qayta yoqilishi zarur. Critical error xabar yuz berganda Sistem Adminstrator uyqusidan turib bo’lsa ham xatolikni bartaraf etishi kerak. builder.Services.AddDbContext<AppDbContext>((provider, options) => { var logger = provider.Services.GetRequiredService<ILogger<Program>>(); var connectionString = builder.Configuration.GetConnectionString(\"Postgres\"); if(string.IsNullOrWhiteSpwace(connectionString)) { logger.LogCritical(\"Postgres connection string not configured.\"); Environment.Exit(-1); } options.UseNqgsql(connectionString); }); Yuqoridagi misollardan ko’rinib turibdi agar dastur davomida yetarlicha log xabarlar qoldirmoqchi bo’lsangiz kodda judaham noise (shovqin — chalg’ituvchi qismlar) juda ko’payib ketadi. Buni oldini olish uchun Logging Abstraction qo’llash kerak. Bu haqida batafsil keyingi postda. Wahid Abduhakimov"
  },
  "dotnet/middleware.html": {
    "href": "dotnet/middleware.html",
    "title": "Middleware tushunchasi | wahidustoz",
    "summary": "Middleware tushunchasi Middleware — bu ASP.NET Core’dagi fundamental va ajralmas qismlardan biri hisoblanadi. U HTTP Request’lar va response’lar ustida amal bajarishimizga yordam beradi. Bugun ushbu maqolada biz middleware haqidagi tushunchalarni, uni qo’llashni ko’rib chiqamiz, kettik \uD83D\uDE80. Middleware o’zi nima Middleware — bu ASP.NET Core pipeline’ida HTTP request’lar va response’lar ustida amal bajarishimiz uchun bizga yordam beradigan dasturning tarkibiy qismi. Har bir middleware ushbu ishlarni amalga oshira oladi: Middleware biror-bir middleware’dan oldinham keyinham ish qila oladi. Request yoki Response’ni o’zgartira oladi. Pipeline’dan short-circuit (ya’ni chiqib ketish) qila oladi va response’ni сразу yubora oladi. Middleware — program.cs’da pipeline’ga qanday ketma-ketlika qo’yilgan/qo’shilgan bo’lsa, usha ketma-ketlikda ishlaydi. Middleware qanday ishlaydi Yuqorida ikki martta ta’kidlaganimizdek, middleware bizga HTTP request yoki response’lar ustida ishlashimizni ta’minlaydi. Middleware’ni ishlatishga — 3 ta asosiy metodlar bor: Use : Pipeline’ga middleware qo’shadi. Run : Terminal middleware qo’shadi, ya’ni pipeline’ni to’xtatuvchi/hal qiluvchi middleware. Map : Request’dan kelib chiqib (ya’ni conditional), pipeline’da yangi branch ochadi (Map’ham terminal middleware hisoblanadi). Ushbu metodlar yordamida middleware yozsak biz anonim metodlar orqali yozamiz ya’ni bu — in-line middleware hisoblanadi. Yoki umuman bu metodlarni ishlatmasdan, reusable (ya’ni alohida class) class’da yozib uni pipeline’ga qo’shib qo’ysakham bo’laveradi. Qanday ishlatamiz o’zi Ushbu rasmda middleware’lar o’zi qanday ishlashi haqida batafsil yoritilgan. E’tibor bering, qora strelka kelib birinchi middleware’ga uriladi, u yerda qandaydur ish bajariladi so’ng next() chaqiriladi. Keyin ikkinchi middleware’ga o’tib ketadi, keyin uchinchiga. Diqqat! 3 chi ya’ni terminal middleware’dan ortga qaytib ketyapti, bu degani birinchi bo’lib 1-2-3 va oxiriga 3-2-1 ya’ni response qaytarish uchun yana oldingi middleware’larga yo’lda kiradi degani, agarda u yerdaham next() dan keyin qandaydur logic yozgan bo’lsangiz ularham ishga tushadi. Misolda ko’ramiz: var builder = WebApplication.CreateBuilder(args); var app = builder.Build(); app.Use(async (context, next) => { Console.WriteLine(\"1 chi Use middleware'da birinchi amal\"); await next.Invoke(); Console.WriteLine(\"1 chi Use middleware'da ikkinchi amal\"); }); app.Use(async (context, next) => { Console.WriteLine(\"2 chi Use middleware'da birinchi amal\"); await next.Invoke(); Console.WriteLine(\"2 chi Use middleware'da ikkinchi amal\"); }); app.Run(async context => { Console.WriteLine(\"-----\"); await context.Response.WriteAsync(\"3 chi middleware (terminal middleware)'dan salom\"); }); app.Run(); Hozir bu kodda birinchi bo’lib birinchi Use middleware ishlaydi, so’ng await next.Invoke() bilan keyingi middleware’ni chaqiradi, keyin 2 chi middleware ishlaydi, so’ng 3 chi — Run ishlaydi. Tepada aytganimdek, pipeline ortga qaytib ketadi, yo’lda Use middleware’larga kiradi. U yerda await next.Invoke() dan keyin ham kod yozilgan, ular tabiiyki ishga tushadi. Xullas output quyidagicha: 1 chi Use middleware'da birinchi amal 2 chi Use middleware'da birinchi amal ----- 2 chi Use middleware'da ikkinchi amal 1 chi Use middleware'da ikkinchi amal 3 chi middleware’dan salom esa, u Respone bo’lganligi uchun website’da ko’rinadi. Run Middleware Run middleware’i Use kabi o’ziga next ni qabul qilmaydi va bu degani Run metodi ichida biz keyingi middleware’ni chaqira olmaymiz. Bu esa Run so’nggi ya’ni short-circuting middleware hisoblanadi. var builder = WebApplication.CreateBuilder(args); var app = builder.Build(); app.Use(async (context, next) => { Console.WriteLine(\"1 chi Use middleware'da birinchi amal\"); await next.Invoke(); Console.WriteLine(\"1 chi Use middleware'da ikkinchi amal\"); }); app.Run(async context => { Console.WriteLine(\"-----\"); await context.Response.WriteAsync(\"3 chi middleware (terminal middleware)'dan salom\"); }); app.Use(async (context, next) => // ushbu middleware hech qachon ishga tushmaydi. { Console.WriteLine(\"2 chi Use middleware'da birinchi amal\"); await next.Invoke(); Console.WriteLine(\"2 chi Use middleware'da ikkinchi amal\"); }); app.Run(); Ushbu kodda ikkinchi Use middleware’i hech qachon ishga tushmaydi, chunki Run ichida next yo’q. Output quyidagicha bo’ladi: 1 chi Use middleware'da birinchi amal ----- 1 chi Use middleware'da ikkinchi amal Diqqat! O’zi aslida ASP.NET Core’da middleware’lar biz uchun yozib qo’yilgan. Hozir ko’rib chiqayotgan Use, Run, va Maplar qo’shimcha middleware qo’shishimizni ta’minlaydi. Bu rasmdagilar o’zi bor middleware’lar. Biz ushbu metodlar bilan Custom Middleware yozamiz. Ammo bizda o’zi bor middleware’lar ustida to’liq nazorat bor (ya’ni biz ularni orasiga o’zimizni middleware’imizni qo’shsak bo’ladi). Middleware’lar ketma-ketligi Program.csda joylashgan bo’ladi. Ularni ketma-ketligi judayam muhim chunki bu xavfsizlikka, dastur ishlashiga to’g’ridan to’g’ri ta’sir o’tkazadi. Map Middleware Map metodi orqali biz pipeline’nni alohida branch (ya’ni shox)ga o’tkaza olamiz. Ya’ni Map ishlatilinayotganda biz PATH beramiz va agarda REQUEST PATH bilan bir-xil bo’lib qolsa, usha branch’ga kirib ketadi va ushbu middleware terminal (ya’ni hal qiluvchi/so’nggisi) bo’ladi. Masalan: var builder = WebApplication.CreateBuilder(args); var app = builder.Build(); app.Map(\"/map1\", HandleMapTest1); app.Map(\"/map2\", HandleMapTest2); app.Run(async context => { await context.Response.WriteAsync(\"Map ishlamagan dasturdan salom\"); }); app.Run(); static void HandleMapTest1(IApplicationBuilder app) { app.Run(async context => { await context.Response.WriteAsync(\"Map Test 1\"); }); } static void HandleMapTest2(IApplicationBuilder app) { app.Run(async context => { await context.Response.WriteAsync(\"Map Test 2\"); }); } Quyidagi jadvalda http://localhost:5000’ga yuborilgan REQUEST va RESPONSE’larni ko’rishingiz mumkin: Request Response http://localhost:5000 Map ishlamagan dasturdan salom http://localhost:5000/map1 Map Test 1 http://localhost:5000/map2 Map Test 2 http://localhost:5000/map3 Map ishlamagan dasturdan salom Ichma-ich Map Map metodi shuningdek ichma-ich mapni qo’llab-quvvatlaydi: app.Map(\"/level1\", level1App => { level1App.Map(\"/level2a\", level2AApp => { // \"/level1/level2a\" ishga tushyapti }); level1App.Map(\"/level2b\", level2BApp => { // \"/level1/level2b\" ishga tushyapti }); }); MapWhen Va MapWhen bor. Bu nafaqat PATH’ni tekshiradi, balki uning so’rovini ham tekshira oladi. Func<HttpContext, bool> ushbu predicate’dan qaytgan qiymat (true yoki false)ga qarab turib yangi branch’ga olib kirib ketadi yoki yo’q. Ushbu misolda query string’ni tekshirib (ya’ni request’da kelgan so’rov)ni tekshirib beradi: var builder = WebApplication.CreateBuilder(args); var app = builder.Build(); app.MapWhen(context => context.Request.Query.ContainsKey(\"Muhammad\"), HandleBranch); app.Run(async context => { await context.Response.WriteAsync(\"Map ishlamagan dasturdan salom.\"); }); app.Run(); static void HandleBranch(IApplicationBuilder app) { app.Run(async context => { var branchVer = context.Request.Query[\"Muhammad\"]; await context.Response.WriteAsync($\"Ishlatilingan branch = {branchVer}\"); }); } Quyidagi jadvalda http://localhost:5000’ga yuborilgan REQUEST va RESPONSE’larni ko’rishingiz mumkin: Request Response http://localhost:5000 Map ishlamagan dasturdan salom http://localhost:5000/?muhammad=main Ishlatilingan branch = main Built-in middleware’lar https://learn.microsoft.com/en-us/aspnet/core/fundamentals/middleware/?view=aspnetcore-9.0#built-in-middleware → ushbu link orqali ASP.NET Core’da biz middleware yozmasak ham, shundoq ham mavjud bo’lgan middleware’lar to’plami mavjud. Kirib o’qib chiqishni maslahat beraman. Muhammad Khodjaev"
  },
  "glossary.html": {
    "href": "glossary.html",
    "title": "Ko'p ishlatiladigan terminlar izohi | wahidustoz",
    "summary": "Ko'p ishlatiladigan terminlar izohi bug Bug bu dasturdagi kutilmagan xatolik. debug (debugging) Dasturni xatolarini aniqlash uchun kod bloklarini qadamma qadam ishga tushirib tekshirish. Debugging jarayoni dasturdagi taxmin qilib topib bolmaydigan buglarni va ularni sababini qidirib topishga yordam beradi. pointer Pointer bu asosiy ma'lumot saqlanadigan xotira manzilini saqlovchi o'zgaruvchi. U ko'rsatuvchi xotira manzilini to'liq boshqarish imkonini beradi. Odatda C/C++ kabi low-level tillarda ishlatiladi. C#/Java kabi high-level tillarda to'g'ridan to'g'ri pointerlar ishlatish tavsiya etilmaydi. reference C#/Java kabi high-level tillarda heap xotira manzilidagi asosiy ma'lumotni ko'rsatuvchi o'zgaruvchi. U xotira manzilini to'g'ridan-to'g'ri manipulatsiya qilish imkonini bermaydi. Reference texnik jihatdan pointerga o'xshab ketadi. .NET muhitida referencelar xotiraga qanday bog'lanishi va ular bog'langa xotira manzillarini boshqarishni CLR bajaradi. frequency Chastota - biror hodisa yoki elementning takrorlanish tezligi. data structure Ma'lumotlarni saqlash, o'qish va o'zgartirish qulay va tez bo'lishi uchun ularni sistematik tartibga solish usuli. Data structures - katta ma'lumotlar to'plamidan maxsuslarini qidirish, tartiblash va joylashtirishni osonlashtiradi. Quyidagilar data structurega misollar: array linked list stack queue tree traverse Data structurelar kontekstida shu strukturani har bir elementiga birma-bir murojat qilib qandaydir operatsiya bajarishni anglatadi. Masalan, loop orqali arrayni har bir elementiga murojat qilish array traversing deb ataladi. node Node - linked list, stack, queue, tree kabi data structurelarni asosi hisoblanadi. Har bir node asosiy ma'lumotdan tashqari strukturadagi boshqa nodelarga reference yoki linkni o'z ichiga oladi. root Tree (daraxtsimon) data strukturalarida eng yuqoridagi node. Tree data strukturani traverse qilish root nodedan boshlanadi. parent Tree (daraxtsimon) data strukturalarda o'zidan pastda bir yoki undan ortiq child-nodega ega bo'lgan node parent node deb ataladi. child Tree (daraxtsimon) data strukturalarda parent-nodega ega bo'lgan node child node deb ataladi. Ma'lumot o'rnida, root node hech qachon child ro'lida bo'la olmaydi. Sababi unda parent-node yo'q. leaf Tree (daraxtsimon) data strukturalarda birorta ham child-nodega ega node leaf node deb ataladi. Boshqacha qilib aytganda leaf shu branch/*(shox)*ni yakuni bo'ladi. subtree Tree (daraxtsimon) data strukturalarida bitta node va uni barcha childlaridan tashkil topgan mini-tree subtree deb ataladi. sibling Tree (daraxtsimon) data strukturalarida umumiy parent-nodega ega bo'lgan barcha bitta nodelar siblings deb ataladi. binary tree Tree (daraxtsimon) data strukturalarida har bir nodei ko'pi bilan 2ta child**ga ega bo'lgan strukturalar binary tree deb ataladi. Child nodelar right node va left node deb ataladi. balanced tree Tree (daraxtsimon) data strukturalarida istalgan nodeni olganda uni o'ng va chapidagi subtree** balandligi uzog'i bilan bitta nodega farq qilsa, bunday tree balanced tree deb ataladi. complete tree Har bir qavati (oxirgi qavatdan tashqari) to'liq to'ldirilgan tree complete tree deb ataladi. Oxirgi qatorda yangi nodelar chapdan o'ngga qarab qo'shib boriladi. Namuna 1 Namuna 2 1 / \\ 2 3 1 / \\ 2 3 / \\ 4 5 heap property Binary Heap data strukturasi kontekstida har bir node tegishli joyda bo'lishini ta'minlovchi shartlarga heap property deb ataladi. Min-heap Max-heap har bir node uchun parent-node qiymati child-nodelar qiymatidan KICHIK yoki teng bo'lishi shart. har bir node uchun parent-node qiymati child-nodelar qiymatidan KATTA yoki teng bo'lishi shart. 2 / \\ 7 5 / \\ 10 8 15 / \\ 10 3 / \\ 5 7 recursion Dasturda funksiya o'z tanasida o'zini chaqirishiga recursion deb ataladi. Loop ishlatmasdan o'zini-o'zi chaqirish recursive funksiyalar muammoni kichik muammochalarga bo'lib tashlab, bir xil logikani qayta-qayta ishlatib hal qiladi. public int Sum(int n) { if (n == 0) return 0; return n + Sum(n - 1); } CLR TODO"
  },
  "index.html": {
    "href": "index.html",
    "title": "| wahidustoz",
    "summary": "\uD83D\uDE80 Wahid Ustoz texnologiya makoni! \uD83D\uDCBB Wahid Ustoz texnologiya makoniga xush kelibsiz! Bu yerda siz .NET, C#, va boshqa mavzular bo'yicha qiziqarli maqolalar to'plamini topasiz. Dasturiy ta'minot ishlab chiqishdagi so'nggi tendensiyalar, qo'llanmalar va eng yaxshi amaliyotlarni o'rganing. Logging Darajalari (va ularni qanday ishlatish kerak) Dasturlaringizda nosozliklarni tuzatish va monitoringni yaxshilash uchun turli logging darajalarini qanday samarali ishlatishni o'rganing. #Logging #Debugging #Monitoring \uD83D\uDCBE Linux Swap: Kompyuteringizni Sekinlashishdan Qanday Himoya Qilish Mumkin? Sizning RAM’ingiz yetarli emasmi? Swap bilan kompyuteringizni tezroq va barqaror ishlashiga yordam bering! Ushbu maqolada swap nima ekanligi, uni qanday yaratish va sozlash haqida sodda va tushunarli tarzda bilib olasiz. \uD83D\uDE80 #Linux #RAM #SWAP Logging Kod Generatorlari .NETda kod generatsiyasi texnikalari yordamida logging samaradorligini qanday oshirishni bilib oling. #KodGeneratsiyasi #Samaradorlik #Logging .NET 8 .NET 8 dagi so'nggi xususiyatlar va yaxshilanishlarni, jumladan samaradorlikni oshirish va yangi imkoniyatlarni o'rganing. #DotNet #Yangiliklar #Samaradorlik ASP.NET Core 8.0 ASP.NET Core 8.0 ning yangi xususiyatlariga, veb va server texnologiyalari yaxshilanishlariga sho'ng'ing. #ASPNETCore #VebDasturlash #Yangiliklar Dto, Model va Entity DTO, Model va Entity o'rtasidagi farqlarni tushuning va ularni dasturlaringizda qanday samarali ishlatishni o'rganing. #Arxitektura #DizaynShablonlari #DotNet Middleware ASP.NET Core da middleware haqida bilib oling va uni dasturlaringizda so'rovlar va javoblarni boshqarish uchun qanday ishlatishni o'rganing. #Middleware #ASPNETCore #VebDasturlash FluentValidation FluentValidation yordamida .NET dasturlaringizda validatsiya mantiqini qanday amalga oshirishni bilib oling. #Validatsiya #DotNet #EngYaxshiAmaliyotlar IHttpClientFactory .NET dasturlarida HTTP so'rovlarini boshqarish uchun IHttpClientFactory dan foydalanishning afzalliklarini o'rganing. #HTTP #DotNet #Tarmoq Task yoki ValueTask Task va ValueTask o'rtasidagi farqlarni va qachon qaysi birini ishlatish kerakligini bilib oling. #CSharp #Asynchronous #Performance C# 12 C# 12 ning yangi xususiyatlari va ularni qanday ishlatishni o'rganing. #CSharp #LanguageFeatures #Updates Hashmaps Hashmaplar haqida bilib oling va ularni samarali ishlatishni o'rganing. #Algorithms #DataStructures #Performance VSCode Setup VSCode ni samarali dasturlash muhiti sifatida sozlashni o'rganing. #Tooling #VSCode #Productivity SSH Key Qo'shish GitHub yoki boshqa xizmatlarga ulanish uchun SSH kalitlarini qanday qo'shishni o'rganing. #Tooling #SSH #Security Bir nechta Git Remote Bir nechta git remote bilan qanday ishlashni o'rganing. #Tooling #Git #VersionControl"
  },
  "patterns/index.html": {
    "href": "patterns/index.html",
    "title": "| wahidustoz",
    "summary": "Design Patterns \uD83E\uDDE9 Dastur hajmi oshib borgani sari uni qo'llab-quvvatlash, eski kodga ta'sir qilmasdan yangi funksiyalar qo'shish va eski funksiyalarni yangi modullarda muammosiz ishlatish murakkablashib boradi. Hech qanday dizayn patternlarga rioya qilinmasa yuqoridagi imkoniyatlar bilan hayrlashishga to'g'ri keladi. Code Basega kichik o'zgarishlar qo'shish ham sistemani juda ko'p qismiga o'zgarish kiritgani uchun barcha o'zgarishlarni tekshirish va testlash imkonsiz bo'lib boradi. Dizayn patternlar qo'llab-quvvatlashga, o'zgartirishga va kengaytirishga oson bo'lgan kod yozish imkonini beruvchi qo'liplardir. Dastur ehtiyojida kelib chiqib bir yoki bir-nechta dizayn patternlarni qo'llab uzoq yillar kengayib boradigan code base quriladi. Dizayn patternlarni quyadigi asosiy maqsadlari mavjud Kodni tartiblash - klass/komponentlarni strukturasi va bir-biri bilan munosabatini tartibga soluvchi qoidalar toplamiga ega Qayta ishlatish - dizayn patternlar qayta ishlatsa bo'ladigan moslashuvchan kod yozishni ta'minlaydi modulyar dizayn - module/komponentlarni mustaqil va boshqa komponentlarga bog'liq bo'lmasligini ta'minlaydi muammolarni yakkalash - faqatgina bitta muammoga e'tibor qaratadigan klasslar yaratishni ta'minlaydi umumiy yechimni abstraktsiyalash - muammolardagi umumiy yechimni/kodni abstraktsiyalash va qayta ishlatishni ta'minlaydi Kengaytirish - dasturni talablari o'sib borgan sari kelajakda kutiladigan o'zgarishlarga moslashuvchan kod yozish imkonini beradi Kommunikatsiya - barcha uchun tanish va uzor yillardan beri standardga aylangan dizayn patternlarni ishlatish orqali code baseni butunlay o'qib chiqmasdan ham tushinsa bo'ladigan, tashqaridan kelgan odamga gapirib yuboradigan kod yozish imkonini beradi stateDiagram-v2 designPatterns: Design Patterns creational: Creational structural: Structural behavioral: Behavioral designPatterns --> creational designPatterns --> structural designPatterns --> behavioral creational: Abstract Factory creational: Builder creational: Factory Method creational: Prototype creational: Singleton structural: Adapter structural: Bridge structural: Composite structural: Decorator structural: Flyweight structural: Proxy behavioral: Chain of Responsibility behavioral: Command behavioral: Interpreter behavioral: Iterator behavioral: Mediator behavioral: Memento behavioral: Observer behavioral: State behavioral: Strategy behavioral: Template Method behavioral: Visitor Dizayn patternlar asosiy 3 kategoriyaga bo'linadi: Creational - obyektlarni yaratish va initsializatsiya qilish jarayonini markazlashtirish, kodni keraksiz qismlariga bog'lanib qolishi(coupling)ni oldini olish uchun ishlatiladi Structural - asosiy vazifasi obyektlarni bir-biri bilan munosabatini qurish va tartiblash. Behavioral - ma'lum funksional maqsadga erishish uchun obyektlar bir-biri bilan qanday aloqa qilshi ko'rsatadi Tip Keyingi postlar dizayn patternlarni har biriga to'xtalib hayotiy misollar bilan tushintirib beraman \uD83E\uDEE1 Wahid Abduhakimov"
  },
  "tooling/CRON.html": {
    "href": "tooling/CRON.html",
    "title": "CRON | wahidustoz",
    "summary": "CRON CRON - Bu Unix-like (o'zbekcha ma'nosini topa olmadim) operatsion tizimlarda ma’lum bir vaqtda skriptlar yoki komandalarni ishga tushirishni avtomatlashtiruvchi va ishga tushish vaqtini belgilovchi foydali tool hisoblanadi. * * * * * * | | | | | | | | | | | +--- Day of the week (0-6) (Sunday=0) | | | | +----- Month (1-12) | | | +------- Day of the month (1-31) | | +--------- Hour (0-23) | +----------- Minute (0-59) +------------- Second (0-59) (optional) Bu CRON sintaksisi bo’lib, unda aslida 5 ta bo’lim (*) bor ammo istasangiz 6 chi bo’limga sekundni yozsangiz ham bo’ladi. (*) Ushbu belgi “har” (каждый) degan ma’noni anglatadi va agar siz ushbu belgini qaysi bo’limda ishlatsangiz, masalan soat bo’limida, shunda dastur har soatda ishlaydi. Bu yerda yulduzchalar 5 ta (sekund yo’q). Demak bu degani dastur har minutda ishlaydi. Bu yerda bo’lsa yulduzchalar soni 6 ta (sekund ham qo’shilgan). Demak dastur har sekundda ishlaydi. 0,30 * * * * * Dastur har 0 chi va 30 chi sekundlarda ishlaydi. E’tibor bering qolgan barchasi yulduzcha, demak har daqiqa, soat, kun, oy va hafta kunlarida ishlaydi. Masalan ushbu vaqtlarda ishlaydi: 12:00:00 12:00:30 12:01:00 12:01:30 va hokazo 30 * * * * * Bu ifodada esa dastur har daqiqaning aynan 30 chi sekundida ishlaydi. Masalan: 12:00:30 12:01:30 12:02:30 12:03:30 va hokazo 0 30 2 * * * Bu yerda esa dastur har kuni soat 02:30 da ishlaydi. 0 30 2 10 10 5 ifodasi pastda. Ifoda: 0 - 0 chi sekund 30 - 30 chi daqiqa 2 - soat 2 10 - oyning 10 chi kuni 10 - yilning 10 chi oyi hafta kunining farqi yo’q Bu yerda dastur shunday qilib har yili 10 chi Oktabrda soat 02:30 da ishga tushadi Lekin huddi shu yerda hafta kuniga 2 (ya’ni seshanba) berganimda, aynan 10 chi Oktabr qachonki seshanbaga tushsa dastur usha yildagina ishga tushardi. 0 9 * * 0 Bu ifodada bo’lsa dastur har yakshanba kuni soat 09:00 da ishga tushadi. (Chunki 0 yakshanbani bildiradi) CRON so’zining kelib chiqishi CRON so’zi yunoncha “CHRONAS” so’zidan olingan bo’lib, “vaqt” degan ma’noni anglatadi. Azure Function Timer Trigger Azure function ham sizga ushbu servisni taqdim etadi. Masalan https//:t.me/muazzinuz_bot va https://t.me/HabitTrackerPlus_bot telegram botlari foydalanuvchilarga eslatmalar yuborishi va holatlarni o’zgartirishi uchun ushbu servisdan foydalanaman. Masalan: public async Task Run([TimerTrigger(\"0,30 * * * *\")] TimerInfo myTimer) { _logger.LogInformation($\"C# Timer trigger function executed at: {DateTime.Now}\"); string timeZoneId = \"Central Asia Standard Time\"; // kod davomi bor } Bu https://t.me/HabitTrackerPlus_bot ning kodidan bir parcha bo’lib, u har yarim soatta ishlaydi chunki ushbu botda foydalanuvchi kunning istalgan yarim soatini tanlashi mumkin. https://t.me/HabitTrackerPlus_bot botidan misol https://t.me/MuazzinUz_bot da esa dastur har daqiqada ishlaydi. Namoz vaqtini oldindan bilsa bo’lmasligi uchun uni har daqiqada ishlaydigan qilgamman. 0 * * * * * bu ifoda har daqiqada ishlasin degani. Muhammad Khodjaev"
  },
  "tooling/add-ssh-key.html": {
    "href": "tooling/add-ssh-key.html",
    "title": "SSH kalitini Github.com'ga qo'shish | wahidustoz",
    "summary": "SSH kalitini Github.com'ga qo'shish Ushbu maqolada SSH kaliti yo'q bo'lsa yangisini ochish va bor bo'lsa Github.com profilimizga qo'shishni ko'rib chiqamiz. 1-bosqich Kompyuterda SSH bormi yoki yo'qmi tekshirish Kompyuterimizda Git Bash'ni ochamiz. ls -al ~/.ssh mana shu komandani kiritamiz. Agarda sizning kompyuteringizda allaqachon SSH key bo'lsa quyidagi fayllardan biri bo'ladi: id_rsa.pub id_ecsda.pub id_ed25519.pub Agarda sizda ushbu fayllardan biri bo'lsa, 4-bosqichga o'tib ketavering! Agarda bo'lmasa, hozir 2 va 3 chi bosqichlarda yangisini ochishni o'rganamiz. 2-bosqich Kompyuterda yangi SSH ochish Git Bash'ni ochamiz ssh-keygen -t ed25519 -C \"your_email@example.com\" mana shu komandani kiritamiz. > Qo'shtirnoq ichiga Github profilingiz ulangan pochta manzilini kiritasiz. (qo'shtirnoq olib tashlanmaydi) SSH'ni saqlash uchun fayl so'raydi. Default holatda berilgan faylga saqlash uchun shunchaki enter'ni bosishingiz kifoya. Ana endi \"Enter passphrase\" so'raydi ya'ni kod. Esingizda qoladigan kodni kiritasiz Va kiritgan kodingizni yana bir bor kiritasiz. 3-bosqich SSH'ni ssh-agent'ga qo'shish PowerShell'ni ochamiz. ssh-add c:/Users/YOU/.ssh/id_ed25519 mana shu komandani kiritamiz Users va YOU degan joyga o'zingizning kompyuteringizdagi fayl nomlarini kiritishingiz esingizdan chiqmasin! 4-bosqich Github.com'ga kirib SSH ni qo'shish PowerShell'ni ochamiz cd .ssh qilib SSH joylashgan faylga kiramiz code . qilib VS Code'da ochib olamiz Kirib .pub bilan tugagan faylga kiramiz va nima bor bo'lsa ushani ko'chirib olamiz (oxirida sizning Github'ga ulangan pochta manzilingiz bo'lishi kerak) Github.com'ga kiramiz va settings qismiga o'tib SSH and GPG keys bo'limiga kiramiz NEW SSH key'ni bosamiz Title degan joyga SSH uchun nom beramiz, masalan Muhammad's SSH Key Key degan joyga .pub bilan tugagan fayldan olgan uzuuun yozuvimizni paste qilamiz Add SSH key'ni bosamiz Sizdan github profilingizning parolini so'rashi mumkin, uni kiritamiz Tabriklayman, siz SSH'ni muvaffaqiyatli qo'shdingiz! Muhammad Khodjaev"
  },
  "tooling/index.html": {
    "href": "tooling/index.html",
    "title": "| wahidustoz",
    "summary": "Tooling ⚙️ Here you will find a collection of useful tools and resources for your development workflow. \uD83D\uDEE0️ ⚙️ ✨ VS Code o'rnatish \uD83D\uDCBE Linux Swap \uD83E\uDE9B VS Code sozlash \uD83D\uDD87️ Bir nechta git remote bilan ishlash \uD83D\uDD22 Versiyalarni raqamlash ⏰ Cron bilan vaqtni boshqarish \uD83D\uDD12 SSH kalitini qo'shish \uD83D\uDE80 Pull Request yaratish san'ati"
  },
  "tooling/linux-swap.html": {
    "href": "tooling/linux-swap.html",
    "title": "\uD83D\uDCBE Linux Swap | wahidustoz",
    "summary": "\uD83D\uDCBE Linux Swap Wahid Abduhakimov Swap nima va uning ahamiyati? Note Tasavvur qiling, sizning xonangiz bor va u kitoblar bilan to‘lib ketgan. Agar yangi kitob qo‘shmoqchi bo‘lsangiz, lekin joy qolmagan bo‘lsa, vaqtincha ba'zi eski kitoblarni javondan olib, boshqa joyga qo‘yishingiz kerak. Keyinchalik kerak bo‘lganda ularni qaytarib olishingiz mumkin. Swap huddi shu jarayon kabi ishlaydi. Linux tizimida operativ xotira (RAM) to‘lib ketganida, tizim ishlamay qolmasligi uchun kam ishlatiladigan ma’lumotlarni swap hududiga (diskda ajratilgan maxsus joy) vaqtincha ko‘chiradi. Shu tariqa, tizim barqaror ishlashda davom etadi. Swap bo‘lmasa nima bo‘ladi? Agar swap bo‘lmasa va operativ xotira to‘lib ketsa, tizim dasturlarni majburan yopishga yoki hatto osilib qolishga majbur bo‘ladi. Tizimda yetarli RAM bo‘lmasa, operatsion tizim muhim bo‘lmagan jarayonlarni yopadi yoki tizim sekinlashib, hatto ishlamay qolishi mumkin. Ayniqsa, kam RAM (masalan, 2GB yoki 4GB) bo'lgan tizimlarda swap juda muhim. Linux tizimida swap yaratish Agar tizimingizda swap yo‘q bo‘lsa yoki mavjud swap hajmini oshirmoqchi bo'lsangiz, quyidagi bosqichlarni bajaring: 1. Swap mavjudligini tekshirish Birinchi navbatda, swap yo‘qligini tekshirib olamiz: swapon --show Agar hech narsa ko‘rinmasa, swap yo‘q degani. 2. Swap fayl yaratish 2GB swap fayl yaratish uchun: sudo fallocate -l 2G /swapfile Agar fallocate ishlamasa, quyidagi usuldan foydalaning: sudo dd if=/dev/zero of=/swapfile bs=1M count=2048 fallocate swap faylni tez yaratadi, lekin ba'zi eski tizimlarda ishlamasligi mumkin. dd usuli esa sekinroq, lekin hamma tizimlarda ishlaydi. 3. Swap fayl uchun ruxsatlarni sozlash Xavfsizlik uchun faqat tizim swap faylga murojaat qila olishi kerak: sudo chmod 600 /swapfile 4. Swap faylni formatlash Swap sifatida sozlash: sudo mkswap /swapfile 5. Swap-ni faollashtirish Endi swap-ni yoqamiz: sudo swapon /swapfile Ishlayotganligini tekshiramiz: free -h swapon --show Agar swap ro‘yxatda ko‘rinsa, demak, hammasi to‘g‘ri ishlamoqda. 6. Swap-ni doimiy qilish Tizimni qayta yuklagandan keyin swap avtomatik ravishda yoqilishi uchun /etc/fstab fayliga quyidagi qatorni qo‘shamiz: echo '/swapfile none swap sw 0 0' | sudo tee -a /etc/fstab Bu qator tizim yuklanganda swap faylni avtomatik ravishda ulaydi. 7. Swapni ishlatish darajasini sozlash (ixtiyoriy) Swappiness - bu tizim qanchalik tez-tez swap-dan foydalanishini belgilaydi. Joriy sozlamani tekshirish: cat /proc/sys/vm/swappiness Odatiy qiymat 60 bo‘ladi. Agar swap kamroq ishlatilishini xohlasangiz, 10 yoki 20 qilib qo‘ying: echo 'vm.swappiness=10' | sudo tee -a /etc/sysctl.conf sudo sysctl -p Agar tizimingizda yetarli RAM bo‘lsa va swap kamroq ishlatilishini istasangiz, bu qiymatni pasaytirish mumkin. Xulosa Swap - Linux tizimining barqaror ishlashida muhim rol o‘ynaydi. Ayniqsa, kam RAM-ga ega kompyuterlar uchun swap hajmini to‘g‘ri sozlash tizim ish faoliyatini sezilarli darajada yaxshilashi mumkin. Tizimingizdagi RAM miqdoriga qarab swap hajmini belgilash tavsiya etiladi: 4GB RAM uchun 2GB swap 8GB RAM uchun 4GB swap 16GB RAM va undan ko‘p bo‘lsa, swap minimal (1GB-2GB) bo‘lishi mumkin. Endi siz swap faylni qanday yaratishni va uni qanday sozlashni bilasiz! \uD83D\uDE80 Agar savollaringiz bo‘lsa, bemalol so‘rang. \uD83D\uDE0A"
  },
  "tooling/multiple-git-remotes.html": {
    "href": "tooling/multiple-git-remotes.html",
    "title": "\uD83D\uDD87️ Bir loyihani bir vaqtda GitHub va GitLabda boshqarish | wahidustoz",
    "summary": "\uD83D\uDD87️ Bir loyihani bir vaqtda GitHub va GitLabda boshqarish Git'da bir nechta remotelarni sozlashni bilasizmi? \uD83E\uDD14 Marhamat, quyidagi super-yengil qadamlar orqali GitHub va GitLab uchun alohida SSH Keylar yaratib, ulardan qanday foydalanishni o'rganib oling! \uD83C\uDF89 \uD83D\uDD11 SSH Keylarni yaratish 1. Terminalda ~/.ssh papkasiga o'tamiz: agar unday papka mavjud bo'lmasa, yaratishni unutmang \uD83D\uDE09 cd ~/.ssh 2. SSH kalitlarlar yaratamiz. GitHub va GitLab email manzillarini to'ldirishni unutmang (email bir xil bo'lsa ham muammo yo'q \uD83D\uDE09): ssh-keygen -t rsa -C \"your@github.email\" ssh-keygen -t rsa -C \"your@gitLAB.email\" 3. Yaratilgan keylar ~/.ssh papkasida saqlanadi. Endi terminalda quyidagini yozib, ~/.ssh papkasida config fayl yaratamiz: code config 4. config faylga quyidagi kodlarni yozamiz va saqlaymiz: Host github.com Hostname github.com User git IdentityFile ~/.ssh/github Host gitlab.com Hostname gitlab.com User git IdentityFile ~/.ssh/gitlab \uD83D\uDD17 SSH Key'larni GitHub va GitLab'ga ulash \uD83D\uDC19 GitHub uchun: GitHub'da Settings > SSH and GPG keys bo'limiga o'ting. New SSH key tugmasini bosing. ~/.ssh/github.pub faylini ochib, ichidagi hamma tekstni nusxa oling. Title maydoniga kalit uchun nom kiriting va nusxa olingan tekstni quyi maydonga joylashtiring. Add SSH Key tugmasini bosing. ✅ \uD83E\uDD8A GitLab uchun: GitLab'da Preferences > SSH Keys sahifasiga o'ting. ~/.ssh/gitlab.pub faylini ochib, ichidagi hamma tekstni nusxa oling. Key maydoniga nusxa olingan tekstni joylashtiring. Title maydoniga kalit uchun nom kiriting va Expiration Datega 1 yillik amal qilish muddatini belgilang (tavsiya qilinadi \uD83D\uDCC5). Add Key tugmasini bosing. ✅ \uD83D\uDD04 Git Remotelarni sozlash Endi kodlaringizni yuklashda HTTPS linklar o'rniga SSH linklardan foydalanishingiz kerak! \uD83D\uDC4C Misol uchun: git remote add github \"github repo ssh link\" git remote add gitlab \"gitlab repo ssh link\" Shundan keyin, bir vaqtning o'zida kodlaringizni ikkala platformaga yuklashingiz mumkin: git push github main git push gitlab main \uD83C\uDF89 You've made it! Hammasi tayyor! Endi siz GitHub va GitLab'ni bir vaqtda boshqarishingiz mumkin. \uD83D\uDC4F\uD83D\uDE80 Wahid Abduhakimov"
  },
  "tooling/pull-request-maslahatlar.html": {
    "href": "tooling/pull-request-maslahatlar.html",
    "title": "\uD83D\uDE80 Sifatli Pull Request yaratish san'ati: Jamoa hamkorligining kaliti | wahidustoz",
    "summary": "\uD83D\uDE80 Sifatli Pull Request yaratish san'ati: Jamoa hamkorligining kaliti \uD83E\uDD14 Pull Request nima? Tasavvur qiling, siz guruh bilan birgalikda katta kitob yozyapsiz. Har bir yozuvchi o'z bobini yozadi, lekin kitobga qo'shishdan oldin, boshqa yozuvchilar uni ko'rib chiqishi kerak. Pull Request (PR) aynan shunday vazifani bajaradi - bu sizning kodingizni asosiy loyihaga qo'shishdan oldin ko'rib chiqish uchun so'rov. \uD83C\uDFE0 Oddiy hayotdan misol Pull Request xuddi uyingizni ta'mirlashga o'xshaydi: Siz - ustasiz \uD83D\uDD28 Uyingiz - asosiy loyiha \uD83C\uDFE0 Ta'mirlash rejangiz - sizning o'zgartirishlaringiz \uD83D\uDCCB Oila a'zolaringiz - jamoadoshlaringiz \uD83D\uDC68‍\uD83D\uDC69‍\uD83D\uDC67‍\uD83D\uDC66 Ta'mirlashni boshlashdan oldin, oilangizga rejangizni ko'rsatib, ularning fikrini so'raysiz. Xuddi shunday, PR orqali jamoadoshlaringizga o'zgartirishlaringizni ko'rsatib, tasdiqlashlarini so'raysiz. \uD83D\uDCA1 Nima uchun Pull Request muhim? 1. Xatolarni oldini olish \uD83D\uDEE1️ Ikki ko'z bitta ko'zdan yaxshi ko'radi. Jamoadoshlaringiz sizning e'tibordan chetda qolgan xatolarni topishi mumkin. 2. Bilim almashish \uD83D\uDCDA PR orqali jamoa a'zolari bir-biridan o'rganadi va loyiha haqida ko'proq ma'lumotga ega bo'ladi. 3. Kod sifatini oshirish ⭐ Ko'rib chiqish jarayoni kodning umumiy sifatini oshiradi va standartlarga muvofiqligini ta'minlaydi. 4. Tarixni saqlash \uD83D\uDCDC Har bir PR loyihaning qanday rivojlanganini ko'rsatuvchi tarixiy hujjat bo'lib xizmat qiladi. 5. Jamoaviy mas'uliyat \uD83E\uDD1D Kod faqat bir kishiga tegishli emas, balki butun jamoa uchun tushunarli va qo'llab-quvvatlanadigan bo'ladi. ✨ Yaxshi Pull Request qanday bo'ladi? \uD83D\uDCCF 1. Kichik va aniq \"Toma-toma ko'l bo'lur\" - o'zbek maqoli Yaxshi PR: ✅ Bitta aniq vazifani hal qiladi ✅ 200-400 qator koddan oshmaydi ✅ 15 daqiqada ko'rib chiqilishi mumkin \uD83D\uDCDD 2. Tushunarli sarlavha va tavsif Yomon misol: \"Bug fix\" \"Yangilanish\" \"Test\" Yaxshi misol: \"\uD83D\uDC1B Foydalanuvchi login qilganda xatolikni tuzatish\" \"✨ Mahsulotlar ro'yxatiga qidiruv funksiyasi qo'shish\" \"\uD83D\uDCF1 Mobil qurilmalar uchun menyuni moslashtirish\" \uD83D\uDCF8 3. Vizual misol (screenshot) Agar sizning o'zgartirishingiz ko'rinadigan bo'lsa, skrinshot yoki GIF qo'shing: ### Oldin: Biror bir rasm ### Keyin: Biror bir rasm \uD83C\uDFAF 4. Aniq maqsad PR tavsifida quyidagilarni ko'rsating: Muammo: Qanday muammoni hal qilyapsiz? Yechim: Qanday hal qildingiz? Natija: Nimaga erishdingiz? \uD83D\uDD27 Pull Request yaratish bosqichlari 1️⃣ Tayyorgarlik # Yangi branch yarating git checkout -b yangi-funksiya # O'zgartirishlarni amalga oshiring # ...kod yozish... # O'zgartirishlarni saqlang git add . git commit -m \"Aniq va tushunarli commit xabar\" 2️⃣ PR shablonini to'ldirish ## \uD83D\uDCCB O'zgartirishlar tavsifi [Bu yerda nima qilganingizni tushuntiring] ## \uD83C\uDFAF Muammo [Qaysi muammoni hal qilyapsiz?] ## \uD83D\uDCA1 Yechim [Qanday hal qildingiz?] ## ✅ Test qilish - [ ] Mahalliy muhitda test qildim - [ ] Barcha testlar muvaffaqiyatli o'tdi - [ ] Mobil qurilmalarda tekshirdim ## \uD83D\uDCF8 Skrinshot/Demo [Agar mavjud bo'lsa] ## \uD83D\uDD17 Bog'liq issue Fixes #123 3️⃣ Ko'rib chiquvchilarni tayinlash Mavzuni yaxshi biladigan jamoadoshlarni tanlang 1-3 ta ko'rib chiquvchi optimal Shoshilinch bo'lsa, Slack/Teams, Telegram orqali xabar bering \uD83C\uDF1F Eng yaxshi amaliyotlar 1. Commit xabarlarini to'g'ri yozing # Yomon ❌ git commit -m \"fix\" git commit -m \"asdf\" git commit -m \"done\" # Yaxshi ✅ git commit -m \"feat: mahsulot qo'shish funksiyasini yaratish\" git commit -m \"fix: login sahifasidagi validatsiya xatosini tuzatish\" git commit -m \"docs: API dokumentatsiyasini yangilash\" 2. O'z PR-ingizni birinchi bo'lib ko'rib chiqing PR yaratishdan oldin: \uD83D\uDD0D O'z kodingizni qaytadan o'qing \uD83E\uDDF9 Keraksiz console.log va commentlarni o'chiring \uD83D\uDCD0 Kod formatlashni tekshiring \uD83E\uDDEA Testlarni ishga tushiring 3. Context (kontekst) bering ## \uD83D\uDD0D Kontekst Bu o'zgartirishlar #125 issue-ni hal qilish uchun qilingan. Foydalanuvchilar mobil qurilmalarda menyuni ochishda qiyinchilikka duch kelishgan. Bu PR mobil uchun alohida menyu qo'shadi. ## \uD83E\uDD14 Muqobil yechimlar 1. CSS Media Query ishlatish - lekin murakkab animatsiyalar uchun mos emas 2. Alohida mobil sahifa - ortiqcha kod takrorlanishi 3. **Tanlangan:** Responsive hamburger menyu - eng optimal yechim 4. Review commentlariga professional javob bering # Yomon javob ❌ \"Men to'g'ri qilganman, o'zingiz xato qilyapsiz\" # Yaxshi javob ✅ \"Rahmat fikringiz uchun! Men bu yondashuvni tanladim chunki: 1. Performance jihatdan tezroq 2. Kelajakda kengaytirish oson 3. Mavjud kod bilan mos keladi Lekin sizning taklifingiz ham mantiqli. Agar xohlasangiz, o'zgartirishim mumkin. Nima deb o'ylaysiz?\" ⚠️ Xatolardan qochish 1. Juda katta PR yaratish ❌ 1000+ qator kod ✅ Kichik, mantiqiy bo'laklarga bo'ling 2. Tavsif yozmaslik ❌ Bo'sh PR tavsif ✅ Batafsil tushuntirish 3. Testlarsiz PR ❌ \"Keyinroq test yozaman\" ✅ Kod bilan birga test yozing 4. Force push qilish ❌ git push --force review paytida ✅ Yangi commitlar qo'shing 5. Shaxsiy qabul qilish ❌ Tanqidni hujum deb qabul qilish ✅ O'rganish imkoniyati deb qarash \uD83C\uDF81 Bonus: PR Review qilish san'ati Ko'rib chiquvchi sifatida: 1. Ijobiy boshlang \"Ajoyib ish! \uD83D\uDC4F Login tezligi ancha yaxshilangan. Bir nechta kichik takliflarim bor...\" 2. Aniq takliflar bering # Yomon ❌ \"Bu kod yomon\" # Yaxshi ✅ \"Bu funksiyani alohida utility funksiya qilib chiqarsak, qayta ishlatish oson bo'lardi. Masalan: ```js function formatDate(date) { // ... } ```\"x 3. Savol bering, buyruq bermang # Yomon ❌ \"Buni o'zgartiring!\" # Yaxshi ✅ \"Bu yondashuvning sababi nima? Async/await ishlatish bu yerda yaxshiroq bo'lmasmidi?\" \uD83D\uDCCA PR Statistikasi Yaxshi jamoalarda: \uD83D\uDCC9 O'rtacha PR hajmi: 200-400 qator ⏱️ Review vaqti: 1-24 soat \uD83D\uDCAC O'rtacha comment soni: 3-10 ta ✅ Birinchi urinishda qabul qilish: 30-40% \uD83C\uDFAF Xulosa Pull Request - bu shunchaki kod qo'shish emas, bu: \uD83E\uDD1D Jamoa bilan hamkorlik \uD83D\uDCDA O'zaro o'rganish \uD83C\uDFD7️ Sifatli mahsulot yaratish \uD83D\uDCA1 Bilim almashish Eslab qoling: \"Yaxshi PR yaratish - bu hunar. Yaxshi review qilish - bu san'at. Ikkalasini birgalikda qilish - bu professional dasturchilik.\" \uD83D\uDE80 Harakatga o'ting! Keyingi PR-ingizda ushbu tamoyillarni qo'llang Jamoadoshlaringizga ulashing PR madaniyatini yaxshilashga hissa qo'shing \uD83D\uDCDA Qo'shimcha resurslar GitHub PR Guidelines GitLab Merge Request Best Practices Effective Pull Requests Muhammad Khodjaev"
  },
  "tooling/semantic-versioning.html": {
    "href": "tooling/semantic-versioning.html",
    "title": "Semantic Versioning (SemVer) | wahidustoz",
    "summary": "Semantic Versioning (SemVer) Umumiy tushuncha Semantic versioning yoxud SemVer dastur yangilanishdagi o’zgarishlar haqidagi ma’lumotni o’zida mujassam etuvchi 3 ta qismga bo’lingan raqamlar kombinatsiyasidan tashkil topgan versiyalash sxemasidir. (Play market/app store lada ko’pchiligimizni ko’zimiz tushgan 2.1.4 | 1.0.0 | 1.0.1 raqamlarga) SemVer ning yozilish formati Versiyalash formati (raqamlar qaysi tartibga ko’ra yozilishi) quyidagidan iborat = ‘MAJOR.MINOR.PATCH’. (Major = asosiy/katta, Minor = mayda/kichik, Patch = huddiki kiyimga yamoq qilgandek) Ularning ma’nosi quyidagicha: MAJOR versiya (’X.y.z’): Qachonki dasturga oldingi versiyasi bilan umuman bir xil holatdan uzoqlashgan yangilik kiritganingizda ushbu raqam bittaga oshadi. Masalan: “lyuboy” kod, skript o’chirib tashlanishi, yoki umuman dastur oldingi holatidan yangi ko’rinishga kelgan bo’lsa. 1.0.0 dan 2.0.0 ga o’zgaradi def calculate_sum(a, b): return a + b # calculate_sum function is removed def calculate_sum(a, b): return a + b def calculate_sum(a, b, c): return a + b + c MINOR versiya (’x.Y.z’): Qachonki dasturga yangi biror-bir narsalar qo’shilganda (masalan yangi endpoint lar, yangi funksiyalar, metodlar, class lar va hokazo) ushbu raqam bittaga oshadi. Va bu yangilanishlar ishlab turgan kod, funkiyalarga o’zgartirish kiritilmasdan qo’shilishi kerak. 1.2.3 dan 1.3.0 ga o’zgaradi def calculate_sum(a, b): return a + b def calculate_sum(a, b): return a + b def calculate_product(a, b): return a * b def greet_user(name): return f\"Hello, {name}!\" def greet_user(name, greeting=\"Hello\"): return f\"{greeting}, {name}!\" PATCH versiya (’x.y.Z’): Qachonki siz xatoliklarni bartaraf etganingizda yoki juda kichik o’zgartirish kiritganingizda ushbu raqam bittada oshadi. Ushbu o’zgartirishlar dasturga yangi imkoniyat/funksiyalar qo’shish yoki ularni o’zgartirish degani emas, balki bu mavjud bo’lgan muammoni bartaraf etish yoki kodning asl mohiyatini buzmasdan uni yaxshilash/tezlashtirishni bildiradi. 1.0.0 dan 1.0.1 ga o’zgaradi def calculate_sum(a, b): return a - b # Noto'g'ri ish harakati # Bu yerda yeg'indini qaytarishi kerak def calculate_sum(a, b): return a + b # Bu yerda esa yeg'indi def get_items(): items = [] for i in range(1000): items.append(i) return items def get_items(): return list(range(1000)) # Kod yaxshilashdi Pre-release versiyalar (Umumiy tushuncha) Pre-release ya’ni dastur ommaga to’liq taqdim etilishidan oldin dasturni ishga tushirish. Ushbu versiyalar dastur hali stabil holatda ishlamayotgani va haliham dastur ishlab chiqilayotgani yoki haliham test qilinayotganini anglatadi. Pre-release versiyalar dasturchilarga yoki testerlarga juda foydali. Ular dasturni asosiy (ya’ni ommaga allaqachon taqdim qilingan) versiyaga ta’sir o’tgazmasdan ishlatib ko’ra olishadi va feedback ya’ni o’z fikrlarini qoldirishlari mumkin. (Pre-release dastur umuman ommaga taqdim qilinishida oldinham chiqishi mumkin albatta) Pre-release ning yozilish formati Huddi MAJON.MINOR.PATCH ni saqlab qolamiz va oldiga shunchaki alpha, beta yoki rc.X larni qo’yamiz: alpha: Bu odatda test qilishning eng birinchi fazasini bildiradi. Odata bu stabil bo’lmagan yoki haliham eksperement qilinayotgan yangiliklarni o’z ichiga oladi ‘1.0.0-alpha’ beta: Bu alpha ga qaraganda stabilroq versiya hisoblanadi. Ammo haliham xatoliklar bo’lishi mumkun va albatta ommaga to’liq taqdim etiladigan produkt hisoblanmaydi. (Qisqa qilib aytganda alpha dan keyingi bosqich). ‘1.0.0-beta’ rc (release candidate): Bu esa beta ga qaraganda stabilroq versiya hisoblanar ekan. Bu odatda mahsulot (dastur)ni testlashning final bosqichini bildiradi. (Qisqaroq esa beta dan keyingi bosqich). ‘1.0.0-rc.1’ Pre-release versiyalarning oshib borishi 1.0.0-alpha dan 1.0.0-alpha.1 ga 1.0.0-beta dan 1.0.0-beta.1 ga 1.0.0-rc.1 dan 1.0.0-rc.2 ga Pre-release lar dasturning birinchi ommaga taqdim qilinishidan oldin ham qo’llanilishi mumkin Eng birinchi test uchun taqdim etiladigan versiya quyidagicha yoziladi: 0.1.0-alpha 0.1.0-beta 0.1.0-rc.1 va bulardan so’ng eng birinchi stabil versiya ommaga taqdim etiladi: 1.0.0 Dokumentatsiya Yangi versiya chiqqanida faqatgina ushbu raqamlardan foylanibgina qolmasdan foydalanuvchilar uchun albatta nima yangiliklar qilingani haqida ma’lumot beruvchi dokumentatsiya yozish esdan chiqmasin. Xulosa SemVer dan foydalanib siz nafaqat dasturni versiyalaysiz balki foydalanuvchilar bilan ishonchli aloqa o’rnata olasiz. Foydalanuvchilar yanglilanish tugmasini bosishdan oldin nima yangilanishlar qo’shilganini bilib olishligi mumkin. Kichik bir kutubxona qilyapsizmi yoki biror bir katta dastur tuzyapsizmi farqi yo’q, SemVer bilan dasturingizni ma’noliroq, chunarliroq versiyalaysiz. Muhammad Khodjaev"
  },
  "tooling/vscode-install.html": {
    "href": "tooling/vscode-install.html",
    "title": "| wahidustoz",
    "summary": ""
  },
  "tooling/vscode-setup.html": {
    "href": "tooling/vscode-setup.html",
    "title": "VS Code setup | wahidustoz",
    "summary": "VS Code setup VS Code dasturini bilmaydigan dasturchi bo’lmasa kerak. U bugunning eng zamonaviy universal va yengil ishlovchi kod tahrirchisi. U orqali hohlagan SDK va framework’da loyihalar amalga oshirsa bo’ladi. Uning kichik hajmli ekani o’rnatish va ishni boshlash uchun juda qulay. Bundan tashqari har bir yo’nalish va tech-stack uchun alohida extension (kengaytma)lar mavjud bo’lib, ular orqali VS Code dasturini tark etmasdan istalgan ishni amalga oshirsa bo’ladi. Shulardan eng muhimlari va aynan .NET dasturchilar uchun zarur bo’lganlari haqida bugun gaplashamiz. Vaqtingiz yo’q bo’lsa manabu yerga keling va profilni bittada yuklab oling! \uD83D\uDC49 Profilni yuklash Ko’rinish Chiroyli, estetik va sodda ko’rinishga ega setup qilishga harakat qilaman. Buning uchun quyidagi extension va o’zgarishlar kerak bo’ladi. Material Icon Theme: PKief.material-icon-theme VS Code har xil fayl turiga qarab turlicha cute ikonkalar ko’rsatadi. Shades of Purple: ahmadawais.shades-of-purple Juda ham sodda va ranglari ajralib turuvchi mavzu. Unda dominant rang to’q ko’k rang. Koddagi sintaks ham yaqqol ajralib ko’zga tashlanib turadi. Font hajmini boshqarish Bundan tashqari editor font (tahrirolvchi fonti)ni osonlik bilan kattalashtirish yoki kichiklashtirish uchun maxsus Shortcut (qisqa kod) yaratilgan. Editor Font’ni kattalashtirish uchun CTRL+SHIFT+= kichiklashtirish uchun esa CTRL+SHIFT+- bossangiz kifoya. Mening ishlash ekranim hajmi katta bo’lgani uchun ekrandan uzoqroqqa o’tib olgan holda fontni kattaroq qilib ishlashni yoqtiraman. Note Shu o’rinda aytib o’tish kerak CTRL+= va CTRL+- tugmalarini SHIFTsiz bosadigan bo’lsangiz butun VS Code oynasi fonti haji o’zgaradi. .NET Essentials Endi asosiy mavzuga o’tamiz. .NET dasturchilari uchun o’rnatib olishi kerak bo’lgan extension va sozlamalar bilan tanishamiz. C# Dev Kit: ms-dotnettools.csdevkit Microsoft tomonidan yaqindagina taqdim etilgan ushbu extension C# uchun eng kerakli uskunalarni va qulayliklarni o’z ichiga oladi. Bulardan intellisense, test explorer va .NET fayllarini sichqoncha orqali qo’shish imkoniyati. Note Ushbu extension bilan birgalikda C# Extension va IntelliCode for C# Dev Kit (AI’ga asoslangan kodni taxmin qilish qurilmasi) qo’shimcha ravishda automatik o’rnatiladi. C# Snippets: jorgeserrano.vscode-csharp-snippets Bu extension orqali C# tilidagi kodlarini yozib o’tirmasdan ularni qisqarmasi orqali automatik kod generate qilsa bo’ladi. Masalan, class so’zini yozgandan keyin TAB tugmasini bossangiz sizga automatik siz turgan fayl nomi bilan bir xil nomga ega klass yaratib beradi. Injiner uchun kerakli Quyidagi extensionlar barcha injinerlar uchun juda foydali va ish tezligini oshirishga yordam beradi. Docker: ms-azuretools.vscode-docker Docker extension orqali sistemadagi docker container va image’larni VS Code’ni tark etmasdan boshqarsa bo’ladi. GitLens — Git supercharged: eamodio.gitlens git ishlatadigan har qanday injiner Git Lens extension o’rnatib olishi shart. Git bilan bog’liq ma’lumotlar shu bitta extension orqali ko’rinadi. Database clients MongoDB for VS Code: mongodb.mongodb-vscode Ushbu extension vscode’ni o’zidan turib MongoDB’ga ulanish va uni boshqarish imkonini beradi. PostgreSQL: ms-ossdata.vscode-postgresql PostgresSQL server uchun eng qulay va yengil ishlovchi klient. SQL Server (mssql): ms-mssql.mssql MSSQL foydalanuvchilari uchun esa quyidagi extension eng foydali bo’ladi. Redis: cweijan.vscode-redis-client Local redis klient, redis instance’lar va cache boshqaruvi uchun ajoyib extension. Profilni yuklash Note Yuqoridagi hammasini hech qanday muammosiz bitta tugma bosish orqali o’rnatib olish uchun quyidagi men ishlatadigan Profil’ni VS Code dasturiga yuklang! Quyidagi linkni oching: .NET (wahidustoz) Rasmda ko’rsatilgan tugmani bosib yangi profil yarating va zavqlaning Wahid Abduhakimov"
  }
}