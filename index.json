{
  "csharp/csharp-12.html": {
    "href": "csharp/csharp-12.html",
    "title": "C# 12 üò≤ | Wahid Ustoz",
    "keywords": "C# 12 üò≤ Ushbu qismda qismda C# 12dagi eng üÜí featurelarni ko'rib chiqamiz. ‚≠ê Primary Constructor class va struct tiplarini elon qilishda bira to'la endi asosiy konstruktor berib ketsa bo'ladi. Primary Constructor orqali yuborilgan obyektlar klass hududi bo'ylab ko'rinadi. Tip Primary constructor orqali yuborilgan obyektlar class memberi emas aksincha parametr ekanini yoddan chiqarmaslik kerak. Ularni this kalit so'zi orqali chaqirib bo'lmaydi. struct misolida. public readonly struct Nuqta(int x, int y) { public readonly int X => x; public readonly int Y => y; } ota classga ma'lumot uzatish. public class Ustoz(int id, string ism) : Ishchi(id) { public int Id => id; public string Ism => ism; } Va eng keraklisi dependency injection. public interface IService { Distance GetDistance(); } public class ExampleController(IService service) : ControllerBase { [HttpGet] public ActionResult<Distance> Get() { return service.GetDistance(); } } üí° Collection Expressions Endi to'plamlarni e'lon qilishda new kalit so'zini ishlatishni hojati yo'q üò≤. int[] sonlar = [1, 2, 3, 4, 5]; List<string> ismlar = [\"Ali\", \"Vali\", \"Hasan\"]; double[] qator1 = [1, 2, 3]; double[] qator2 = [4, 5, 6]; // ko'p o'lchamli array yasash double[][] jadval = [qator1, qator2, [7, 8, 9]]; üí£ Spead Operator Agar yuqoridagilari hali miyyangizni portlatmagan bo'lsa unda bunisiga qarang. Spread Operator .. yordami mavjud to'plamlarni yangi to'plamga osonlik bilan qo'shing! string[] qizlar = [\"Madina\", \"Hadicha\", \"Aisha\"]; string[] yigitlar = [\"Umar\", \"Ali\", \"Abubakr\"]; string[] hamma = [\"Wahid\", ..yigitlar, ..qizlar]; // hamma = [\"Wahid\", \"Umar\", \"Ali\", \"Abubakr\", \"Madina\", \"Hadicha\", \"Aisha\"] üå† Default Lambda parameters lambda expression elon qilishda endi uning parametrlariga default qiymatlarni berib ketsa bo'ladi. var yuza = (int a, int? b = null) => a * (b ?? a); Console.WriteLine(yuza(5)); // 25 Console.WriteLine(yuza(5, 6)); // 30 Bu yangi feature eng ko'p ishlatilishi kutilyapkan yana bir misol. app.MapGet(\"/users\", async (IUserService service, int? page = 1, int? pageSize = 50) => { }); Tip Yuqorida lambda expression yangi imkoniyatidan foydalanib Pagination uchun default qiymatlar berib ketilgan."
  },
  "csharp/index.html": {
    "href": "csharp/index.html",
    "title": "C# related posts | Wahid Ustoz",
    "keywords": "C# related posts Here you will find a comprehensive collection of resources and information meticulously curated for C# enthusiasts. Task vs ValueTask C# 12 üò≤"
  },
  "csharp/task-yoki-valuetask.html": {
    "href": "csharp/task-yoki-valuetask.html",
    "title": "Task yoki ValueTask? | Wahid Ustoz",
    "keywords": "Task yoki ValueTask? Task va uning jenerik sherigi Task<TResult> klasi ancha vaqtlardan beri bor va har bir .NETchi asinxron dasturlash uchun uni ishlatib ko‚Äôrgan. .NET Core 2.0dan boshlab yangi klas ValueTask va ValueTask<TResult> olib kirildi. Ho‚Äôsh siz ulardan qaysi birini ishlatishingiz kerak? Qisqa qilib aytganda, agarda siz kutubxona yozayotgan bo‚Äôlsangiz va shu kutubxona xotirani va resurslarni judayam kam sarflashi zarur bo‚Äôlgan joylarda ishlatilsa, siz ValueTask haqida bosh qotirsangiz arziydi. Lekin ValueTask ishlatishda judayam extiyotkor bo‚Äôlish kerak. Odatiy kunlik ishlarda esa Senior darajada bo‚Äôlmagan dasturchilar Task klasi ishlatgani ma‚Äôqul. Ushbu postni oxirigacha o‚Äôqib tushinib olganingizdan keyin darajangizdan qatiy nazar ValueTask va Taskni qayerda va qanday ishlatishni tushinib olasiz. Task/Task<TResult> Task klasining vaziflari ko‚Äôp. Qisqa qilib aytganda u uzoq vaqt davom etadigan ish qaytaradigan ma‚Äôlumotni o‚Äôrash uchun wrapper sifatida ishlatiladi va promise ya‚Äôni va‚Äôda deyiladi. Qaytarilgan Task obyektini hohlagan vaqtda await qilib kutib turgan holda natijasini olsa bo‚Äôladi. Bundan tashqari shu obyektni hohlagancha qayta-qayta yoki parallel bir nechta threadda await qilsa ham bir xil natija qaytaradi. Bu judaham kuchli yechim! async Task<int> GetNaturalGasPriceInUsdAsync() { await Task.Delay(1000); return 9; } var uzbekNaturalGasPrice = GetNaturalGasPriceInUsdAsync(); var price = await uzbekNaturalGasPrice; var price2 = await uzbekNaturalGasPrice; Yuqoridagi kodda ko‚Äôrinib turibdiki bitta Task obyektini bir necha marta await qilish mumkin va u bir xil natija qaytaradi. Muammo Unda muammo nimada? Gap shundaki, Task va Task<TResult> klas tiplar bo‚Äôlib har safar asinxron funksiya chaqirilganda Task yoki Task<TResult> allocate (xotirani o‚Äôzlashtirish) qilib qaytarishga to‚Äôg‚Äôri keladi. Hullas, har safar funksiya chaqirilganda yangi instance yaratib qaytarish dastur tezligi va xotira samaradorligiga sezilarli ta‚Äôsir qiladi. Runtimedagi yechimlar Ko‚Äôp hollarda asinxron funksiyalar sodda bo‚Äôladi va ularni bir marta await orqali chaqirish kifoya bo‚Äôladi. ... await SendEmailAsync(email, cancellationToken); ... Bundan tashqari, ko‚Äôp hollarda asinxron funksiya ham ishini sinxron tugatadi ya‚Äôni quyidagi misoldagidek ma‚Äôlum shartlar bajarilsagina asinxron ish bajariladi yo‚Äôqsa funksiya ishini sinxron tugatib Task qaytaradi. public async Task SendEmailAsync(Email email, CancellationToken cancellationToken = default) { if(email is not null) await client.SendEmailAsync(email, cancellationToken); logger.LogInformation(\"Email not sent!\"); } Ushbu koddan tushinish mumkinki ba‚Äôzi hollarda funksiya hech qanday asinxron ish bajarilmaydi. Bunday holatlar juda ham ko‚Äôp takrorlangani uchun .NET Runtime o‚Äôzi Taskning hech qanday asinxron ish bajarilmaganda qaytariladigan nusxasini Cache qilib oladi va qayta-qayta ishlataveradi. Bu o‚Äôsha biz bilgan Task.CompletedTask obyekti. Yuqoridagi kodda agar email null bo‚Äôlsa Runtime o‚Äôzi Task.CompletedTaskni cachedan olib qaytaradi. Agar asinxron ish bajarilsa, yangi Task obyekti allocate qilib qaytariladi. Yana bir misolga qarang. Bir Task<bool> qaytaradigan funksiya bor. Bu funksiyada 3 xil holat bor: darxol sinxron true qaytaradi darxol sinxron false qaytaradi asinxron ravishda uzoq vaqtda true yoki false qaytaradi. Dastlabki ikki holatda Task<bool>dan yangi obyekt allocate qilib qaytarish shart emas. 2 ta dona qiymat bo‚Äôlgani uchun Runtime ularni allaqachon Cache saqlab qo‚Äôygan bo‚Äôladi va o‚Äôshalarni qaytaradi. Ya‚Äôni yangi xotira allocate qilinmaydi. Agar funksiya asinxron ish bajarsa, majburan Task<bool> obyekti allocate qilinadi. Quyidagi snippet shuni ko‚Äôrsatadi. public async Task<bool> ShouldSendEmailAsync(User user, CancellationToken cancellationToken = default) { if(user is null) return false; if(user.IsNew()) return true; return await IsNotAdminAsync() } Lekin hamma narsani ham Cache qilish practical yechim emas. Masalan, Task<int> qaytaradigan funksiyani hamma bo‚Äôlishi mumkin bo‚Äôlgan natijalarni Cacheda saqlash Gigabaytlab xotira talab qiladi. Ko‚Äôplab kutibxonalar shunday Cache texnikasidan foydalanib yangi obyektlar yaratilishini oldini olishadi. Masalan, MemoryStream.ReadAsync funksiyadi Task<int> obyekti orqali nechta bayt o‚Äôqilganini qaytaradi. Bu funksiya ko‚Äôpincha bir xil son qaytargani uchuni ichkarida birinchi qaytarilgan Task<int> obyekti Cache qilinadi. Keyingi safar chaqirilganda, agar yana o‚Äôshancha bayt o‚Äôqigan bo‚Äôlsa eski Cache qilingan obyekt qaytariladi. Yo‚Äôqsa Task.FromResult ishlatib yangi obyekt yaratiladi. Bu funksiya .NET yangi versiyalarida ValueTask<int> qaytaradigan qilib update qilingan. ValueTask<TResult> Yuqoridagi yechimni yanada takomillashtirish uchun .NET Core 2.0dan boshlab ValueTask<TResult> struct tanishtirildi. U asinxon funksiyalardan qaytariladi va TResult yoki Task<TResult> uchun wrapper vazifasini bajaradi. Agar asinxron funksiya muvaffaqiyatli sinxron yakunlansa, ValueTask<TResult> structi TResult ga initialize qilib qaytarialdi. Hech qanday allocation bo‚Äôlmaydi. Agar asinxron yakunlansa yoki qandaydir exception sodir bo‚Äôlsa, yangi Task<TResult> obyekti allocate qilib ValueTask<TResult>ga o‚Äôrab qaytariladi. Buning yordamida yuqorida keltirilgan MemoryStream.ReadBytes funksiyasi quyidagicha takomillashtirildi. Endi hech qanday Cache ishlatilmaydi. public override ValueTask<int> ReadAsync(byte[] buffer, int offset, int count) { try { int bytesRead = Read(buffer, offset, count); return new ValueTask<int>(bytesRead); } catch (Exception e) { return new ValueTask<int>(Task.FromException<int>(e)); } } Muhim narsa qolib ketyapti await dasturlash yo‚Äôlining eng muhim xususiyatlaridan biri bu asinxron operatsiya yakunlanganda chaqirish imkonini beruvchi callback method bilan ta‚Äôminlash. Ya‚Äôni Task/Task<TResult> qaytaradigan asinxron funksiyalarga ish tugatilganda chaqiriladigan callback method bersangiz bo‚Äôladi. async Task<ZipArchive> CreateZipArchiveFromCloudFiles() { var files await DownloadAllFilesToTempFolderAsync(); return await CreateZipAsync(files); } var zipArchive = await CreateZipArchiveFromCloudFiles() .ContinueWith(async (task) => { await CleanupTempFolderAsync(); }); Buni amalga oshirish uchun xotirada shu operatsiyani aks ettiruvchi obyekt saqlanishi kerak va u orqali callback method chaqirilishi kerak. Shu hususiyatni ta‚Äôminlash uchun .NET Core 2.1dan boshlab IValueTaskSource<TResult> interface tanishtirildi. Bu interface asinxron operatsiya holati haqida ma‚Äôlumot saqlaydi va OnCompleted methodi orqali unga yuqoridagidan callback method bersa bo‚Äôaldi. *IValueTaskSource<TResult> haqida keyingi postlarda.* Endi ValueTask<TResult> va ValueTask structlari birgalikda asinxron funsiyalarni har qanday holatda ham hech qanday hotira allocate qilmasdan natija qaytarish imkonini beradi. ValueTask ishlatishdagi havf ValueTask va ValueTask<TResult> qisqa qilib aytganda oddiy holatlarda bir marta await qilib ishlatiladigan Tasklar uchun chiqarilgan. Quyidagi holatlarda hech qachon ValueTask / ValueTask<TResult> ishlatmaslik kerak. ValueTask / ValueTask<TResult> ni bir martadan ortiq await qilish. ValueTask<TResult> ichidagi TResult obyekti GC tomonidan recycle qilib yuborilgan bo‚Äôlishi yoki boshqa operatsiya tomonidan ishlatilayotgan bo‚Äôlishi mumkin **ValueTask / ValueTask<TResult>**ni bir vaqta bir nechta threaddanawait qilish. Yuqoridagiday TResult obyekti bitta thread ishini tugatgach recycle qilib yuborilgan bo‚Äôlishi mumkin. Operatsiya yakunlanmasidan avval .GetAwaiter().GetResult() funksiyasi orqali blok qilib natijani kutish. IValueTaskSource va IValueTaskSource<TResult> interfacelari blok qilish imkoniyatini bermaydi. Agar sizga yuqoridagi imkoniyatlar chindan ham zarur bo‚Äôlsa, .AsTask() methodi orqali ValueTask/ValueTask<TResult> larni Taskga aylantirib olsangiz bo‚Äôladi. Ushbu maqolada qandaydir xatolik topsangiz habar bering."
  },
  "dotnet/aspnetcore-8.html": {
    "href": "dotnet/aspnetcore-8.html",
    "title": "ASP.NET Core 8.0 | Wahid Ustoz",
    "keywords": "ASP.NET Core 8.0 ASP.NET Core nima ekanini yoddan chiqarganlar uchun eslatib o'taman, bu .NET Frameworkni asosan web texnologiyalari uchun javobgar qismi. ASP.NET Core 8 web va server texnologiyalari samaradorligini oshiradigan minglab performance improvement va yangi featurelar taqdim etdi. Blazor üî• .NET 8 versiyasidan boshlab Blazor endi to'laqonli Web UI frameworkga aylandi. U orqali sayt kontentlarini page yoki component levelida qayta render qilsa bo'ladi. Blazor avval 2 xil versiyaga ega edi. Server UI elementlari serverda render qilinib kerakli vaqtda SignalR orqali o'zgargan elementlargina klientga yuboriladi. bu birinchi parta saytni tortishda juda tez lekin juda katta server resurslari talab qiladi WASM UI elementlari to'liqligicha klient brauzerida render bo'ladi. birinchi marta saytni tortib olishga uzoq vaqt ketadi. serverdagi havfsizlik va boshqa server imkoniyatlari mavjud emas Blazor app yasashdan avval 2ta tanlovdan birini tanlashga to'g'ri kelar edi va butun sayt bo'ylab yoki Server yoki WASM rejimda ishlar edi. üì¢ Endi Blazor render turini global sayt bo'yicha emas Page/Component levelida boshqarsa bo'ladi. Blazorni yangi Hybrid vesiyasida istalgan Component yoki Pageni server/wasm render bo'lishini boshqarsa bo'ladi. Bu orqali saytni birinchi marta tortib olish yorug'lik tezligida bo'ladi va unda keyin barcha renderin brauzerda WASM usulida amalga oshiriladi. Bundan tashqari Blazorda yana yuzlab yangiliklar bor. Ularni bu yerda o'qib oling. üé• Batafsil mana bu yerda 2X tezlikda ko'rib oling! Minimal API üòâ .NET 8dagi qo'shimchalarning ko'p qismi Native AOT va Source Generatorlar bilan bog'liq. Ular compile time vaqtida kerakli kodlarni generate qiladi va bu orqali runtime performance sezilarli oshiriladi. Form binding Avvalgi versiyalarida IFormFile va IFormCollection orqali form elementlariga erishish imkoni bor edi. Lekin MVC Controllerlar kabi [FromForm] attribute orqali form elementlarini Model objectga bog'lashni iloji yo'q edi. .NET 8 Minimal API endi bu ishni qila oladi. app.MapPost(\"/register\", async([FromForm] RegisterModel model) => { // register logic }); Mana bu postda bu haqida batafsil! Native AOT Support Native AOT orqali publish qilingan dasturlarni hajmi juda kichi bo'ladi, ular juda tez ishga tushadi va juda ham kam RAM talab qiladi. Bu yerda batafsil o'qing!"
  },
  "dotnet/dotnet-8.html": {
    "href": "dotnet/dotnet-8.html",
    "title": ".NET 8 üéâ | Wahid Ustoz",
    "keywords": ".NET 8 üéâ Qaynoqqina yangilik, .NET Foundation yaqindagina .NET SDK 8ni ommaga taqdim etdi. Ushbu post orqali undagi eng qiziqarli o'zgarishlar va yangiliklar bilan tanishamiz. .NET 8 SDK yuklash Avvalo .NET 8ni o'rnatishdan boshlaymiz. Quyidagi powershell komandasini tering. winget install Microsoft.DotNet.SDK.8 Tip Menga o'xshab Nerd bo'lmaganlar üëâ shu link orqali o'zlariga kerakli installerni tortib olishlari mumkin. Tip C# 12 bilan bog'liq yangiliklarni bu yerda o'qing! Tip ASP.NET Core 8.0 bilan bog'liq yangiliklarni bu yerda o'qing! ‚ö†Ô∏è Har bir yangi qo'shilgan Feature ustida batafsil postlarni shu yerda berib boraman. Yangiliklardan qolib ketmaslik uchun Telegram kanalimga obuna bo'ling!"
  },
  "dotnet/index.html": {
    "href": "dotnet/index.html",
    "title": ".NET and ASP.NET related posts | Wahid Ustoz",
    "keywords": ".NET and ASP.NET related posts Here you will discover an extensive array of the most recent news, cutting-edge features, and essential updates for .NET. üì∞ ‚ú® Logging Levels (and how to use them) Logging Code Generators .NET 8 ASP.NET Core 8.0"
  },
  "dotnet/log-code-gen.html": {
    "href": "dotnet/log-code-gen.html",
    "title": "Improve logging performance with code generation | Wahid Ustoz",
    "keywords": "Improve logging performance with code generation Avvalgi postda logging levels __(logging darajalari)__ni tushintirib bergan edim. Bugun logging tezligini oshirish uchun taklif etilayotgan yangi feature Logging Code Generation haqida gaplashamiz. Code generation bu yangilik emas. Avvaldan Blazor, Razor va shunga o'xshash engine'lar compile vaqtida kod generate qiladi. .NET 6 versiyasida olib kirilgan yangi attribute LoggingMessageAttribute bo'lsa aynan Logging samaradorligini oshirish uchun compile vaqtida reusable logging funksiyalari yaratish uchun ishlatiladi. Ushbu qo'shimcha haqida batafsil bu yerda o'qishingiz mumkin. Logging Code generation ishlatish uchun static partial klas yaratib uni ichida partial kalit so'zi orqali methodlar elon qilishingiz kerak. Bu methodlarni tanasi compile vaqtida .NET tomonidan yaratiladi va qayta ishlatiladi. public static partial class ValidationFilterLoggings { [LoggerMessage( EventId = 0, Level = LogLevel.Trace, Message = \"Fluent validation started for type {targetType}.\")] public static partial void LogValidationStarted( this ILogger logger, string targetType); } E'lon qilingan funksiyani tanasi compile vaqtida .NET tomonidan yaratiladi. Keyin ushbu logging methodni quyidagicha ishlatsa bo'ladi. public class AsyncFluentValidationFilter<T> : IEndpointFilter where T : class { private readonly ILogger<AsyncFluentValidationFilter<T>> logger; public AsyncFluentValidationFilter(ILogger<AsyncFluentValidationFilter<T>> logger) => this.logger = logger; public async ValueTask<object> InvokeAsync(EndpointFilterInvocationContext context, EndpointFilterDelegate next) { ... logger.LogValidationStarted(nameof(T)); ... } } Note Yuqorida elon qilingan LogValidationStarted funksiyasi ILogger interface ustiga qurilgani uchun, bu methodni istalgan ILogger interface obyektida ishlatsa bo'ladi. Agar sizga maxsus bitta generic ILogger<T> ustida ishlaydigan mehod kerak bo'lsa, this ILogger<T> shaklida elon qilishingiz kerak. Misol uchun quyidagi kodga qarang üëÄ public static partial class ValidationFilterLoggings { [LoggerMessage( EventId = 1, Level = LogLevel.Trace, Message = \"Fluent validation for {targetType} is successful.\")] public static partial void LogValidationCompleted( this ILogger<AsyncFluentValidationFilter<T>> logger, string targetType); }"
  },
  "dotnet/log-levels.html": {
    "href": "dotnet/log-levels.html",
    "title": "Logging Levels | Wahid Ustoz",
    "keywords": "Logging Levels Logging dasturni eng muhim qismlaridan biri hisoblanadi. Ko‚Äôpchilik unga katta e‚Äôtibor bermasa ham Logging to‚Äôg‚Äôri qilinmasa juda katta mablag‚Äô va vaqt yo‚Äôqotilishiga olib kelishi mumkin. Odam yozgan lyuboy sistemada Bug ü™≤ bo‚Äôladi. Dastur ishga tushgandan keyin kelib chiqqan xatoliklarni dasturda yozib borilayotgan Loglarsiz qidirib topishni imkoni yo‚Äôq. Bugungi postda Log Levels ya‚Äôni log xabarlarni muhimlik darajalariga qarab qanday ishlatishni o‚Äôrganamiz. 1. Trace ‚Äî logger.LogTrace() Bu turdagi loglar dastur davomidagi har bir qadamni batafsil yozib ketish uchun ishlatiladi. Yangi jarayon, funksiya, loop yoki oqim boshlanishi va tugaganidan keyin iz qoldirish uchun Trace log yozib ketiladi. public async Task ProcessOrder(CustomerOrder order) { logger.LogTrace(\"Starting order processing for OrderId: {OrderId}\", order.OrderId); // Validate the order if (IsOrderValid(order)) { logger.LogTrace(\"Order validation successful for OrderId: {OrderId}\", order.OrderId); // Perform necessary actions such as updating inventory, sending notifications, etc. logger.LogTrace(\"Persisting order with OrderId: {OrderId}\", order.OrderId); await storage.PersistOrderAsync(order); logger.LogTrace(\"Publishing OrderCreated message with OrderId: {OrderId}\", order.OrderId); await messaging.PublishOrderCreated(order); } } 2. Debug ‚Äî logger.LogDebug() Bu turdagi log Tracega juda ham yaqin, lekin yagona farqi Debug log ichida o‚Äôzgaruvchilar qiymatlari batafsilroq yoritiladi. Shu sababli bu turdagi log ichida maxfiy ma‚Äôlumotlar bo‚Äôlishi mumkin. Debug va Trace log miqdori juda katta bo‚Äôlgani uchun odatda Production muhitda o‚Äôchirib qo‚Äôyish tavsiya qilinadi. Shaxsiy fikrimcha Debug yoki Trace darajasidan kamida bittasi Production muhitda ham ko‚Äôrinishi kerak. public async Task ProcessOrder(CustomerOrder order) { logger.LogTrace(\"Starting order processing for OrderId: {OrderId}\", order.OrderId); logger.LogDebug(\"Processing order: {Order}\", order); // Validate the order if (IsOrderValid(order)) { logger.LogTrace(\"Order validation successful for OrderId: {OrderId}\", order.OrderId); logger.LogDebug(\"Order validation successful for: {Order}\", order); // Perform necessary actions such as updating inventory, sending notifications, etc. logger.LogTrace(\"Persisting order with OrderId: {OrderId}\", order.OrderId); logger.LogDebug(\"Persisting order: {order}\", order); await storage.PersistOrderAsync(order); logger.LogTrace(\"Publishing OrderCreated message with OrderId: {OrderId}\", order.OrderId); logger.LogDebug(\"Publishing OrderCreated for order: {order}\", order); await messaging.PublishOrderCreated(order); } } Summary Yuqorida keltirilgan LogTrace va LogDebug odatda dasturchilar uchun yo‚Äônaltirilgan bo‚Äôladi. Ya‚Äôni bu turdagi loglarni odatda developerlar BUGü™≤ni qidirib topish uchun ishlatishadi. 3. Information ‚Äî logger.LogInformation() Bu turdagi log odatda biror katta jarayon boshlanishi va muvaffaqiyatli tugaganini ko‚Äôrsatish uchun ketiladi. Trace va Debugdan farqli o‚Äôlaroq, Information turidagi xabarlar miqdori juda kam bo‚Äôladi. Bunday log ichida iloji boricha maxfiy ma‚Äôlumotlar ko‚Äôrsatilmasligi kerak. public async Task ProcessOrder(CustomerOrder order) { logger.LogTrace(\"Starting order processing for OrderId: {OrderId}\", order.OrderId); logger.LogDebug(\"Processing order: {Order}\", order); // Validate the order if (IsOrderValid(order)) { logger.LogTrace(\"Order validation successful for OrderId: {OrderId}\", order.OrderId); logger.LogDebug(\"Order validation successful for: {Order}\", order); // Perform necessary actions such as updating inventory, sending notifications, etc. logger.LogTrace(\"Persisting order with OrderId: {OrderId}\", order.OrderId); logger.LogDebug(\"Persisting order: {order}\", order); await storage.PersistOrderAsync(order); logger.LogTrace(\"Publishing OrderCreated message with OrderId: {OrderId}\", order.OrderId); logger.LogDebug(\"Publishing OrderCreated for order: {order}\", order); await messaging.PublishOrderCreated(order); logger.LogInformation(\"Order with orderId {OrderId} successfully processed.\", order.Id); } } 4. Warning ‚Äî logger.LogWarning() Warning xabarlar dasturda kutilmagan holat yoki noto‚Äôg‚Äôri ma‚Äôlumot paydo bo‚Äôlganda qoldiriladi. Bunday holat yuz berganda dasturchi, sistema admini yoki dasturni o‚Äôzi ham hech qanday amal bajarish orqali xatoni tuzatishga urinishi shart emas. Bu xabarni muhim tarafi, sistemadagi bu kutilmagan holat keyinchalik e‚Äôtibor talab etuvchi jiddiy xatolikka olib borishi mumkin. public async Task ProcessOrder(CustomerOrder order) { logger.LogTrace(\"Starting order processing for OrderId: {OrderId}\", order.OrderId); logger.LogDebug(\"Processing order: {Order}\", order); // Validate the order if (IsOrderValid(order)) { logger.LogTrace(\"Order validation successful for OrderId: {OrderId}\", order.OrderId); logger.LogDebug(\"Order validation successful for: {Order}\", order); // Perform necessary actions such as updating inventory, sending notifications, etc. logger.LogTrace(\"Persisting order with OrderId: {OrderId}\", order.OrderId); logger.LogDebug(\"Persisting order: {order}\", order); await storage.PersistOrderAsync(order); logger.LogTrace(\"Publishing OrderCreated message with OrderId: {OrderId}\", order.OrderId); logger.LogDebug(\"Publishing OrderCreated for order: {order}\", order); await messaging.PublishOrderCreated(order); logger.LogInformation(\"Order with orderId {OrderId} successfully processed.\", order.Id); } else { logger.LogDebug(\"Validation failed for order {order}\", order); // batafsil ma'lumot qoldirish uchun logger.LogWarning(\"Validation failed for order with id: {OrderId}\", order.Id); logger.LogDebug(\"Publishing OrderFailed for order: {order}\", order); await messaging.PublishOrderFailed(order); } } 5. Error ‚Äî logger.LogError() Error xabarlar biror katta yumush bajarish jarayonida xatolik yuz berib shu funksiya oxiriga yeta olmasa qoldiriladi. Error xabar qoldirilish shu jarayon oxiriga yetmay qolganini lekin sistemaning boshqa qismlariga ta‚Äôsir qilmasligini anglatadi. Odatda Error xabarlarni sistemani o‚Äôzinig Error Handling, Retry mexanizmlari bartafar qiladi. Ayrim hollarda operatorlar ma‚Äôlumot xolatini o‚Äôzgartirish orqali ham bu Error holatdan chiqib ketishlari mumkin. Error xabar yuz berganda Operatorlar yoki dasturchilar uyqularidan turib bo‚Äôlsa ham shu xatolikni bartaraf etishlari kerak. Shuning uchun bu turdagi xatoliklarni log qilishda shoshilmaslik kerak. Operator va dasturchini uyqusini buzishga arziydimi degan savolni berish kerak. public async Task ProcessOrder(CustomerOrder order) { logger.LogTrace(\"Starting order processing for OrderId: {OrderId}\", order.OrderId); logger.LogDebug(\"Processing order: {Order}\", order); // Validate the order if (IsOrderValid(order)) { logger.LogTrace(\"Order validation successful for OrderId: {OrderId}\", order.OrderId); logger.LogDebug(\"Order validation successful for: {Order}\", order); try { // Perform necessary actions such as updating inventory, sending notifications, etc. logger.LogTrace(\"Persisting order with OrderId: {OrderId}\", order.OrderId); logger.LogDebug(\"Persisting order: {order}\", order); await storage.PersistOrderAsync(order); logger.LogTrace(\"Publishing OrderCreated message with OrderId: {OrderId}\", order.OrderId); logger.LogDebug(\"Publishing OrderCreated for order: {order}\", order); await messaging.PublishOrderCreated(order); } catch(DbException ex) { logger.LogError(\"Order processing failed for order with id: {OrderId}\", order.Id); throw new OrderProcessingFailedException(order, ex); } logger.LogInformation(\"Order with orderId {OrderId} successfully processed.\", order.Id); } else { logger.LogDebug(\"Validation failed for order {order}\", order); // batafsil ma'lumot qoldirish uchun logger.LogWarning(\"Validation failed for order with id: {OrderId}\", order.Id); logger.LogDebug(\"Publishing OrderFailed for order: {order}\", order); await messaging.PublishOrderFailed(order); } } 6. Critical ‚Äî logger.LogCritical() Bunday Log sistemani barcha qismlarini ishdan chiqaruvchi xatolikni yozish uchun ishlatiladi. Masalan, RAM yoki SSD xotira tugab qolishi, butun dastur bo‚Äôylab Database‚Äôga bog‚Äôlana olmaslik yoki shunga o‚Äôxshash dastur ishlashi uchun so‚Äôzsiz kerak resursni yo‚Äôqligi. Bunday xatoliklar dastur davomida bir marta yuz beradi. Ya‚Äôni Critical error yuz bergandan keyin dastur o‚Äôchib qolishi va Sistem adminstrator tomonidan qayta yoqilishi zarur. Critical error xabar yuz berganda Sistem Adminstrator uyqusidan turib bo‚Äôlsa ham xatolikni bartaraf etishi kerak. builder.Services.AddDbContext<AppDbContext>((provider, options) => { var logger = provider.Services.GetRequiredService<ILogger<Program>>(); var connectionString = builder.Configuration.GetConnectionString(\"Postgres\"); if(string.IsNullOrWhiteSpwace(connectionString)) { logger.LogCritical(\"Postgres connection string not configured.\"); Environment.Exit(-1); } options.UseNqgsql(connectionString); }); Yuqoridagi misollardan ko‚Äôrinib turibdi agar dastur davomida yetarlicha log xabarlar qoldirmoqchi bo‚Äôlsangiz kodda judaham noise (shovqin ‚Äî chalg‚Äôituvchi qismlar) juda ko‚Äôpayib ketadi. Buni oldini olish uchun Logging Abstraction qo‚Äôllash kerak. Bu haqida batafsil keyingi postda."
  },
  "index.html": {
    "href": "index.html",
    "title": "üöÄ Wahid Ustoz tech space! üíª | Wahid Ustoz",
    "keywords": "üöÄ Wahid Ustoz tech space! üíª .NET Discover valuable tips and in-depth tutorials related to .NET and ASP.NET Core. C# Language Explore the latest language features explained in a clear and accessible manner. Happy coding! üéâ ‚å®Ô∏è"
  },
  "patterns/index.html": {
    "href": "patterns/index.html",
    "title": "Design Patterns üß© | Wahid Ustoz",
    "keywords": "Design Patterns üß© Dastur hajmi oshib borgani sari uni qo'llab-quvvatlash, eski kodga ta'sir qilmasdan yangi funksiyalar qo'shish va eski funksiyalarni yangi modullarda muammosiz ishlatish murakkablashib boradi. Hech qanday dizayn patternlarga rioya qilinmasa yuqoridagi imkoniyatlar bilan hayrlashishga to'g'ri keladi. Code Basega kichik o'zgarishlar qo'shish ham sistemani juda ko'p qismiga o'zgarish kiritgani uchun barcha o'zgarishlarni tekshirish va testlash imkonsiz bo'lib boradi. Dizayn patternlar qo'llab-quvvatlashga, o'zgartirishga va kengaytirishga oson bo'lgan kod yozish imkonini beruvchi qo'liplardir. Dastur ehtiyojida kelib chiqib bir yoki bir-nechta dizayn patternlarni qo'llab uzoq yillar kengayib boradigan code base quriladi. Dizayn patternlarni quyadigi asosiy maqsadlari mavjud Kodni tartiblash - klass/komponentlarni strukturasi va bir-biri bilan munosabatini tartibga soluvchi qoidalar toplamiga ega Qayta ishlatish - dizayn patternlar qayta ishlatsa bo'ladigan moslashuvchan kod yozishni ta'minlaydi modulyar dizayn - module/komponentlarni mustaqil va boshqa komponentlarga bog'liq bo'lmasligini ta'minlaydi muammolarni yakkalash - faqatgina bitta muammoga e'tibor qaratadigan klasslar yaratishni ta'minlaydi umumiy yechimni abstraktsiyalash - muammolardagi umumiy yechimni/kodni abstraktsiyalash va qayta ishlatishni ta'minlaydi Kengaytirish - dasturni talablari o'sib borgan sari kelajakda kutiladigan o'zgarishlarga moslashuvchan kod yozish imkonini beradi Kommunikatsiya - barcha uchun tanish va uzor yillardan beri standardga aylangan dizayn patternlarni ishlatish orqali code baseni butunlay o'qib chiqmasdan ham tushinsa bo'ladigan, tashqaridan kelgan odamga gapirib yuboradigan kod yozish imkonini beradi stateDiagram-v2 designPatterns: Design Patterns creational: Creational structural: Structural behavioral: Behavioral designPatterns --> creational designPatterns --> structural designPatterns --> behavioral creational: Abstract Factory creational: Builder creational: Factory Method creational: Prototype creational: Singleton structural: Adapter structural: Bridge structural: Composite structural: Decorator structural: Flyweight structural: Proxy behavioral: Chain of Responsibility behavioral: Command behavioral: Interpreter behavioral: Iterator behavioral: Mediator behavioral: Memento behavioral: Observer behavioral: State behavioral: Strategy behavioral: Template Method behavioral: Visitor Dizayn patternlar asosiy 3 kategoriyaga bo'linadi: Creational - obyektlarni yaratish va initsializatsiya qilish jarayonini markazlashtirish, kodni keraksiz qismlariga bog'lanib qolishi(coupling)ni oldini olish uchun ishlatiladi Structural - asosiy vazifasi obyektlarni bir-biri bilan munosabatini qurish va tartiblash. Behavioral - ma'lum funksional maqsadga erishish uchun obyektlar bir-biri bilan qanday aloqa qilshi ko'rsatadi Tip Keyingi postlar dizayn patternlarni har biriga to'xtalib hayotiy misollar bilan tushintirib beraman ü´°"
  },
  "tooling/index.html": {
    "href": "tooling/index.html",
    "title": "Tooling ‚öôÔ∏è | Wahid Ustoz",
    "keywords": "Tooling ‚öôÔ∏è Here you will find a collection of useful tools and resources for your development workflow. üõ†Ô∏è ‚öôÔ∏è VS Code o'rnatish ‚ú® VS Code sozlash ü™õ"
  },
  "tooling/vscode-install.html": {
    "href": "tooling/vscode-install.html",
    "title": "| Wahid Ustoz",
    "keywords": ""
  },
  "tooling/vscode-setup.html": {
    "href": "tooling/vscode-setup.html",
    "title": "VS Code setup | Wahid Ustoz",
    "keywords": "VS Code setup VS Code dasturini bilmaydigan dasturchi bo‚Äôlmasa kerak. U bugunning eng zamonaviy universal va yengil ishlovchi kod tahrirchisi. U orqali hohlagan SDK va framework‚Äôda loyihalar amalga oshirsa bo‚Äôladi. Uning kichik hajmli ekani o‚Äôrnatish va ishni boshlash uchun juda qulay. Bundan tashqari har bir yo‚Äônalish va tech-stack uchun alohida extension (kengaytma)lar mavjud bo‚Äôlib, ular orqali VS Code dasturini tark etmasdan istalgan ishni amalga oshirsa bo‚Äôladi. Shulardan eng muhimlari va aynan .NET dasturchilar uchun zarur bo‚Äôlganlari haqida bugun gaplashamiz. Vaqtingiz yo‚Äôq bo‚Äôlsa manabu yerga keling va profilni bittada yuklab oling! üëâ Profilni yuklash Ko‚Äôrinish Chiroyli, estetik va sodda ko‚Äôrinishga ega setup qilishga harakat qilaman. Buning uchun quyidagi extension va o‚Äôzgarishlar kerak bo‚Äôladi. Material Icon Theme: PKief.material-icon-theme VS Code har xil fayl turiga qarab turlicha cute ikonkalar ko‚Äôrsatadi. Shades of Purple: ahmadawais.shades-of-purple Juda ham sodda va ranglari ajralib turuvchi mavzu. Unda dominant rang to‚Äôq ko‚Äôk rang. Koddagi sintaks ham yaqqol ajralib ko‚Äôzga tashlanib turadi. Font hajmini boshqarish Bundan tashqari editor font (tahrirolvchi fonti)ni osonlik bilan kattalashtirish yoki kichiklashtirish uchun maxsus Shortcut (qisqa kod) yaratilgan. Editor Font‚Äôni kattalashtirish uchun CTRL+SHIFT+= kichiklashtirish uchun esa CTRL+SHIFT+- bossangiz kifoya. Mening ishlash ekranim hajmi katta bo‚Äôlgani uchun ekrandan uzoqroqqa o‚Äôtib olgan holda fontni kattaroq qilib ishlashni yoqtiraman. Note Shu o‚Äôrinda aytib o‚Äôtish kerak CTRL+= va CTRL+- tugmalarini SHIFTsiz bosadigan bo‚Äôlsangiz butun VS Code oynasi fonti haji o‚Äôzgaradi. .NET Essentials Endi asosiy mavzuga o‚Äôtamiz. .NET dasturchilari uchun o‚Äôrnatib olishi kerak bo‚Äôlgan extension va sozlamalar bilan tanishamiz. C# Dev Kit: ms-dotnettools.csdevkit Microsoft tomonidan yaqindagina taqdim etilgan ushbu extension C# uchun eng kerakli uskunalarni va qulayliklarni o‚Äôz ichiga oladi. Bulardan intellisense, test explorer va .NET fayllarini sichqoncha orqali qo‚Äôshish imkoniyati. Note Ushbu extension bilan birgalikda C# Extension va IntelliCode for C# Dev Kit (AI‚Äôga asoslangan kodni taxmin qilish qurilmasi) qo‚Äôshimcha ravishda automatik o‚Äôrnatiladi. C# Snippets: jorgeserrano.vscode-csharp-snippets Bu extension orqali C# tilidagi kodlarini yozib o‚Äôtirmasdan ularni qisqarmasi orqali automatik kod generate qilsa bo‚Äôladi. Masalan, class so‚Äôzini yozgandan keyin TAB tugmasini bossangiz sizga automatik siz turgan fayl nomi bilan bir xil nomga ega klass yaratib beradi. Injiner uchun kerakli Quyidagi extensionlar barcha injinerlar uchun juda foydali va ish tezligini oshirishga yordam beradi. Docker: ms-azuretools.vscode-docker Docker extension orqali sistemadagi docker container va image‚Äôlarni VS Code‚Äôni tark etmasdan boshqarsa bo‚Äôladi. GitLens ‚Äî Git supercharged: eamodio.gitlens git ishlatadigan har qanday injiner Git Lens extension o‚Äôrnatib olishi shart. Git bilan bog‚Äôliq ma‚Äôlumotlar shu bitta extension orqali ko‚Äôrinadi. Database clients MongoDB for VS Code: mongodb.mongodb-vscode Ushbu extension vscode‚Äôni o‚Äôzidan turib MongoDB‚Äôga ulanish va uni boshqarish imkonini beradi. PostgreSQL: ms-ossdata.vscode-postgresql PostgresSQL server uchun eng qulay va yengil ishlovchi klient. SQL Server (mssql): ms-mssql.mssql MSSQL foydalanuvchilari uchun esa quyidagi extension eng foydali bo‚Äôladi. Redis: cweijan.vscode-redis-client Local redis klient, redis instance‚Äôlar va cache boshqaruvi uchun ajoyib extension. Profilni yuklash Note Yuqoridagi hammasini hech qanday muammosiz bitta tugma bosish orqali o‚Äôrnatib olish uchun quyidagi men ishlatadigan Profil‚Äôni VS Code dasturiga yuklang! Quyidagi linkni oching: .NET (wahidustoz) Rasmda ko‚Äôrsatilgan tugmani bosib yangi profil yarating va zavqlaning"
  }
}